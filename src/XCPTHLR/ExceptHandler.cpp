/*  
Module : EXCEPTHANDLER.CPP
Purpose: Implementation for a class which intercepts and logs details about unhandled exceptions
         such as access violations, stack overflows and division by zero.
         The class is based upon the February 2002 MSDN article called "Under the Hood: Improved
         Error Reporting with DBGHELP 5.1 by Matt Pietrek. 

         References:

         Bugslayer,      MSJ,  August 1998 by John Robbins, http://www.microsoft.com/msj/defaultframe.asp?page=/msj/0898/bugslayer0898.htm
         Under the Hood, MSDN, March 2002 by Matt Pietrek,  http://msdn.microsoft.com/msdnmag/issues/02/03/Hood/Hood0203.asp

Created: PJN / 14-03-2002
History: PJN / 20-03-2003 1. Now includes flags to limit what is displayed in the log file. 
                          2. These flag values and the location of the log file can now optionally be configured at
                          run time via registry values.
         PJN / 26-03-2003 1. Tidied up #pragma message text
                          2. Removed the unused variable m_bAppendToLog
                          3. Changed the default flags the class uses
                          4. Flag values and location of the log file can now optionally be configured at run time
                          via an API in the XCPTHLR dll ifself. This is now documented and implemented in the XCPTHLR 
                          module.
                          5. Reworked the sample app to be a GUI based app, where you can change the crash handler 
                          flags manually. Also the crash is now generated by hitting a button.
         PJN / 27-03-2003 1. Now pulls in DbgHelp support via GetProcAddress. This makes the code more robust in the absence
                          of the DbgHelp dll
         PJN / 19-04-2003 1. Now optionally writes out the raw machine code at each call stack frame
                          2. Now optionally writes out the raw stack at each call stack frame.
                          3. Now optionally writes out the process list on the machine
                          4. Now optionally writes out system details including Computer Name, User Name, Number of Processors,
                          Page Size, lowest memory address, highest memory address, OS details, OS version, OS Build, OS
                          service pack, OS type, Windows Directory, Windows System Directory, Registered Organisation 
                          and Registered User.
                          5. Now optionally writes out the environment strings 
                          6. Tidied up some indentation and alignment problems.
         PJN / 20-04-2003 1. Removed usage of CRT function "_tcsicmp" in preference to lstrcmpi
                          2. Removed old unused pragma error entry
                          3. Now optionally writes out stats as returned from GlobalMemoryStatus
                          4. Code now requires a recent copy of the Platform SDK to compile
                          5. Now optionally writes out display device stats
                          6. Now optionally writes out Code page stats
                          7. Now optionally writes out Locale and language stats
                          8. Now optionally writes out boot type
         PJN / 22-04-2003 1. Fixed a problem in LogRawMemory which was causing an access violation.
                          2. Now uses GetDC and GetDevCaps to report screen settings instead of EnumDisplaySettings as 
                          a more reliable mechanism.
         PJN / 01-06-2003 1. Now optionally logs the File Version details for all processes and dlls which are included
                          in the log files.
         PJN / 19-11-2003 1. Fixed a bug in CExceptionLogger::GetAddressDetails in the usage of VirtualQuery. Thanks to 
                          Fredrik Savander for reporting this problem.
         PJN / 21-07-2006 1. Updated copyright details.
                          2. Integrated the functionality of _EXCEPTION_LOGGER_DATA into the CExceptionLogger class
                          3. Code now uses newer C++ style casts instead of C style casts.
                          4. Updated the code to clean compile on VC 2005
                          5. Now includes support for logging of Windows Longhorn Server and Windows Vista
                          6. Now includes support for logging of Windows Server 2003 R2
                          9. Now includes support for logging of various suite flags including: Embedded, Storage Server,
                          Security Appliance, BackOffice components, MS Small Business Server, Enterprise Edition, Terminal Services,
                          Datacenter Edition, Home Edition, Web Edition, Media Center Edition, Tablet Edition 
                          10. Updated documentation to use the same style as the web site.
                          11. Now logs the GDI and User object count.
                          12. Now reports Page Faults, Peak Working Set Size, Working Set Size, Peak Paged pool, Paged pool usage
                          Peak Non-paged pool usage, Non-paged pool usage, Peak Pagefile usage and Pagefile usage.
                          13. Now reports if running on Wow64 
                          14. Now reports the process handle count
                          15. Now reports if the process is running in a terminal services environment
                          16. Now reports the Terminal services Session id value
                          17. Updated code to work correctly for x64 Windows.
                          18. Exception log file can now be accessed by other apps while CExceptionLogger is writing to it.
                          19. Now reports the info returned from GetNativeSystemInfo
                          20. Now reports the info returned from GetSystemWow64Directory
                          21. Now reports if 3D-Now, cmpxchg, Floating point software emulation, Pentium FDIV bug, MMX, DEP, 
                          PAE, RDTSC, SSE, SSE2, SSE3, cmpxchg16b and cmp8xchg16 are supported
                          22. Now reports the Shared Windows directory
                          23. Now reports if the program is running on the Terminal Services session currently attached to the 
                          physical console
                          24. Now reports on various Terminal Services values returned from WTSQuerySessionInformation
                          25. Now reports the total number of pages commited by the system, the current maximum number of page commits,
                          the maximum number of page commit totals since last reboot, the total amount of physical memory in pages,
                          the amount of physical memory available to user process in pages, the total amount of system cache memory in
                          pages, the total amount of the sum of paged and nonpaged kernel pools in pages, the total amount of paged
                          kernel pool in pages, the total amount of nonpaged kernel pool in pages, the size of a page, the total
                          number of open handles, the total number of processes and the total number of threads.
                          26. Added support for returning information from WTSQuerySessionInformation.
                          27. Memory dump is shown as upper case hex now.
                          28. Now reports the info returned from GetCurrentHwProfile
                          29. Segment registers are now shown as 4 byte values 
         PJN / 22-01-2008 1. Updated to support creating minidumps
                          2. The location for the logging file and the minidump file is now your temp directory. This means 
                          that files will be correctly created even with least-privileged user accounts, and it also prevents the
                          files from taking up hard drive space after they are no longer needed.
                          3. The name for the logging file is "YYMMDDHHMMSS.mmm name of exe.exception".
                          4. The name for the minidump file is "YYMMDDHHMMSS.mmm name of exe.dmp".
                          5. Support for EXCEPTION_LOGGER_ONE_EXCEPTION_PER_FILE has been dropped as now the filenames include timestamps
                          to make them unique.
                          6. Updated sample app to clean compile on VC 2005 + VC 2008.
                          7. Updated copyright details.
                          8. Updated sample app to remove VC 6 style appwizard comments
                          9. Updated sample app to use C++ style casts instead of C style casts
                          10. Because the logging and minidump files now are hard coded to include timestamps, the SetXCPTHLRFileName 
                          function has been replaced with SetXCPTHLRDirectory. By default this is set to your temp directory. A corollary
                          SetXCPTHLRDirectory function is now also available.
                          11. Updated usage instructions in the documentation.
                          12. Binaries included in download are now build with VC 2005 SP1

Copyright (c) 2002 - 2008 by PJ Naughter (Web: www.naughter.com, Email: pjna@naughter.com)

All rights reserved.

Copyright / Usage Details:

You are allowed to include the source code in any product (commercial, shareware, freeware or otherwise) 
when your product is released in binary form. You are allowed to modify the source code in any way you want 
except you cannot modify the copyright details at the top of each module. If you want to distribute source 
code with your application, then you are only allowed to distribute versions released by the author. This is 
to maintain a single distribution point for the source code. 

*/


/////////////////////// Includes //////////////////////////////////////////////

#include "stdafx.h"
#include "ExceptHandler.h"
//#include "XCPTHLR.h"
//#include <tchar.h>
#include <stdio.h>


/////////////////////// Macros / Defines //////////////////////////////////////

//Automatically pull in the various libraries we need
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "version.lib")

//Table from Platform SDK's WinUser.h file
#ifndef SM_TABLETPC
#define SM_TABLETPC 86
#endif

#ifndef SM_MEDIACENTER
#define SM_MEDIACENTER 87
#endif

#ifndef SM_SERVERR2
#define SM_SERVERR2 89
#endif

#ifndef SM_REMOTESESSION
#define SM_REMOTESESSION 0x1000
#endif

#ifndef SM_CMONITORS
#define SM_CMONITORS 80
#endif

#ifndef SM_XVIRTUALSCREEN
#define SM_XVIRTUALSCREEN 76
#endif 

#ifndef SM_YVIRTUALSCREEN
#define SM_YVIRTUALSCREEN 77
#endif

#ifndef SM_CXVIRTUALSCREEN
#define SM_CXVIRTUALSCREEN 78
#endif

#ifndef SM_CYVIRTUALSCREEN
#define SM_CYVIRTUALSCREEN 79
#endif

//Taken from recentish Platform SDK's WinNT.h file
#ifndef VER_SUITE_STORAGE_SERVER
#define VER_SUITE_STORAGE_SERVER 0x00002000
#endif 

#ifndef VER_SUITE_COMPUTE_SERVER
#define VER_SUITE_COMPUTE_SERVER 0x00004000
#endif

#ifndef PF_XMMI64_INSTRUCTIONS_AVAILABLE
#define PF_XMMI64_INSTRUCTIONS_AVAILABLE 10   
#endif

#ifndef PF_NX_ENABLED
#define PF_NX_ENABLED 12   
#endif

#ifndef PF_SSE3_INSTRUCTIONS_AVAILABLE
#define PF_SSE3_INSTRUCTIONS_AVAILABLE 13   
#endif

#ifndef PF_COMPARE_EXCHANGE128
#define PF_COMPARE_EXCHANGE128 14
#endif

#ifndef PF_COMPARE64_EXCHANGE128
#define PF_COMPARE64_EXCHANGE128 15
#endif

#ifndef GR_GDIOBJECTS
#define GR_GDIOBJECTS 0
#endif

#ifndef GR_USEROBJECTS
#define GR_USEROBJECTS 1
#endif

#ifndef MiniDumpWithThreadInfo
#define MiniDumpWithThreadInfo 0x1000
#endif

#ifndef MiniDumpWithFullMemoryInfo
#define MiniDumpWithFullMemoryInfo 0x800
#endif


//Taken from recentish Platform SDK's psapi.h (Note we need to define our own version as they is no easy
//way that I knowof to detect if it is not already defined
typedef struct _XCPTHLR_PROCESS_MEMORY_COUNTERS_EX {
    DWORD cb;
    DWORD PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivateUsage;
} XCPTHLR_PROCESS_MEMORY_COUNTERS_EX;
typedef XCPTHLR_PROCESS_MEMORY_COUNTERS_EX *XCPTHLR_PPROCESS_MEMORY_COUNTERS_EX;


//Statics used by the CExceptionLogger class
TCHAR CExceptionLogger::m_szLogFilename[_MAX_PATH] = _T("");
TCHAR CExceptionLogger::m_szMiniDumpFilename[_MAX_PATH] = _T("");
TCHAR CExceptionLogger::m_szDirectory[_MAX_PATH] = _T("");
DWORD CExceptionLogger::m_dwFlags = EXCEPTION_LOGGER_ENUMERATE_THREADS   | EXCEPTION_LOGGER_ENUMERATE_MODULES   |
                                    EXCEPTION_LOGGER_REGISTERS           | EXCEPTION_LOGGER_CALLSTACK           |
                                    EXCEPTION_LOGGER_CALLSTACK_SYMBOLS   | //EXCEPTION_LOGGER_FILE_BUFFERING      |
                               //     EXCEPTION_LOGGER_RAW_CALLSTACK_CODE  | EXCEPTION_LOGGER_RAW_CALLSTACK_STACK | 
                                    EXCEPTION_LOGGER_ENUMERATE_PROCESSES | EXCEPTION_LOGGER_SYSTEM_DETAILS     // | 
                                //    EXCEPTION_LOGGER_ENVIRONMENT_STRINGS | EXCEPTION_LOGGER_DLL_VERSION_DETAILS | 
                                //    EXCEPTION_LOGGER_EXE_VERSION_DETAILS | EXCEPTION_LOGGER_MINIDUMP;
									;
LPTOP_LEVEL_EXCEPTION_FILTER CExceptionLogger::m_pPreviousFilter = NULL;
HANDLE CExceptionLogger::m_hLogFile = INVALID_HANDLE_VALUE;
TCHAR CExceptionLogger::m_szTempLogLine[] = _T("");
TCHAR CExceptionLogger::m_szTempFileName[] = _T("");
BYTE CExceptionLogger::m_bySymbolInfo[];
CExceptionLogger::LPCREATETOOLHELP32SNAPSHOT CExceptionLogger::m_lpfnCreateToolhelp32Snapshot = NULL;
CExceptionLogger::LPTHREAD32FIRST CExceptionLogger::m_lpfnThread32First = NULL;
CExceptionLogger::LPTHREAD32NEXT CExceptionLogger::m_lpfnThread32Next = NULL;
CExceptionLogger::LPMODULE32FIRST CExceptionLogger::m_lpfnModule32First = NULL;
CExceptionLogger::LPMODULE32NEXT CExceptionLogger::m_lpfnModule32Next = NULL;
CExceptionLogger::LPPROCESS32FIRST CExceptionLogger::m_lpfnProcess32First = NULL;
CExceptionLogger::LPPROCESS32NEXT CExceptionLogger::m_lpfnProcess32Next = NULL;
CExceptionLogger::LPOPENTHREAD CExceptionLogger::m_lpfnOpenThread = NULL;
CExceptionLogger::LPGLOBALMEMORYSTATUSEX CExceptionLogger::m_lpfnGlobalMemoryStatusEx = NULL;
CExceptionLogger::LPSYMCLEANUP CExceptionLogger::m_lpfnSymCleanup = NULL;
CExceptionLogger::LPSYMENUMSYMBOLS CExceptionLogger::m_lpfnSymEnumSymbols = NULL;
CExceptionLogger::LPSYMSETOPTIONS CExceptionLogger::m_lpfnSymSetOptions = NULL;
CExceptionLogger::LPSYMINITIALIZE CExceptionLogger::m_lpfnSymInitialize = NULL;
CExceptionLogger::LPSYMSETCONTEXT CExceptionLogger::m_lpfnSymSetContext = NULL;
CExceptionLogger::LPSYMGETLINEFROMADDR64 CExceptionLogger::m_lpfnSymGetLineFromAddr64 = NULL;
CExceptionLogger::LPSYMFROMADDR CExceptionLogger::m_lpfnSymFromAddr = NULL;
CExceptionLogger::LPSTACKWALK64 CExceptionLogger::m_lpfnStackWalk64 = NULL;
CExceptionLogger::LPSYMFUNCTIONTABLEACCESS64 CExceptionLogger::m_lpfnSymFunctionTableAccess64 = NULL;
CExceptionLogger::LPSYMGETMODULEBASE64 CExceptionLogger::m_lpfnSymGetModuleBase64 = NULL;
CExceptionLogger::LPSYMGETTYPEINFO CExceptionLogger::m_lpfnSymGetTypeInfo = NULL;
CExceptionLogger::LPGETGUIRESOURCES CExceptionLogger::m_lpfnGetGuiResources = NULL;
HMODULE CExceptionLogger::m_hDbgHelp = NULL;
HMODULE CExceptionLogger::m_hPsapi = NULL;
CExceptionLogger::LPGETPROCESSMEMORYINFO CExceptionLogger::m_lpfnGetProcessMemoryInfo = NULL;
CExceptionLogger::LPISWOW64PROCESS CExceptionLogger::m_lpfnIsWow64Process = NULL;
CExceptionLogger::LPGETPROCESSHANDLECOUNT CExceptionLogger::m_lpfnGetProcessHandleCount = NULL;
CExceptionLogger::LPPROCESSIDTOSESSIONID CExceptionLogger::m_lpfnProcessIdToSessionId = NULL;
CExceptionLogger::LPGETNATIVESYSTEMINFO CExceptionLogger::m_lpfnGetNativeSystemInfo = NULL;
CExceptionLogger::LPGETSYSTEMWOW64DIRECTORY CExceptionLogger::m_lpfnGetSystemWow64Directory = NULL;
CExceptionLogger::LPISPROCESSORFEATUREPRESENT CExceptionLogger::m_lpfnIsProcessorFeaturePresent = NULL;
CExceptionLogger::LPGETSYSTEMWINDOWSDIRECTORY CExceptionLogger::m_lpfnGetSystemWindowsDirectory = NULL;
HMODULE CExceptionLogger::m_hWtsApi32 = NULL;
CExceptionLogger::LPWTSGETACTIVECONSOLESESSIONID CExceptionLogger::m_lpfnWTSGetActiveConsoleSessionId = NULL;
CExceptionLogger::LPWTSQUERYSESSIONINFORMATION CExceptionLogger::m_lpfnWTSQuerySessionInformation = NULL;
CExceptionLogger::LPWTSFREEMEMORY CExceptionLogger::m_lpfnWTSFreeMemory = NULL;
CExceptionLogger::LPGETPERFORMANCEINFO CExceptionLogger::m_lpfnGetPerformanceInfo = NULL;
HMODULE CExceptionLogger::m_hAdvapi32 = NULL;
CExceptionLogger::LPGETCURRENTHWPROFILE CExceptionLogger::m_lpfnGetCurrentHwProfile = NULL;
CExceptionLogger::LPMINIDUMPWRITEDUMP CExceptionLogger::m_lpfnMiniDumpWriteDump = NULL;


/////////////////////// Implementation ////////////////////////

CExceptionLogger::CExceptionLogger()
{
  //Load up the Kernel function pointers
  HMODULE hKernel32 = GetModuleHandle(_T("KERNEL32.DLL"));
  if (hKernel32)
  {
    m_lpfnOpenThread               = reinterpret_cast<LPOPENTHREAD>(GetProcAddress(hKernel32, "OpenThread"));
    m_lpfnCreateToolhelp32Snapshot = reinterpret_cast<LPCREATETOOLHELP32SNAPSHOT>(GetProcAddress(hKernel32, "CreateToolhelp32Snapshot"));
    m_lpfnThread32First            = reinterpret_cast<LPTHREAD32FIRST>(GetProcAddress(hKernel32, "Thread32First"));
    m_lpfnThread32Next             = reinterpret_cast<LPTHREAD32NEXT>(GetProcAddress(hKernel32, "Thread32Next"));
#ifdef _UNICODE
    m_lpfnModule32First = reinterpret_cast<LPMODULE32FIRST>(GetProcAddress(hKernel32, "Module32FirstW"));
    m_lpfnModule32Next  = reinterpret_cast<LPMODULE32NEXT>(GetProcAddress(hKernel32, "Module32NextW"));
    m_lpfnProcess32First = reinterpret_cast<LPPROCESS32FIRST>(GetProcAddress(hKernel32, "Process32FirstW"));
    m_lpfnProcess32Next = reinterpret_cast<LPPROCESS32NEXT>(GetProcAddress(hKernel32, "Process32NextW"));
    m_lpfnGetSystemWow64Directory = reinterpret_cast<LPGETSYSTEMWOW64DIRECTORY>(GetProcAddress(hKernel32, "GetSystemWow64DirectoryW"));
    m_lpfnGetSystemWindowsDirectory = reinterpret_cast<LPGETSYSTEMWINDOWSDIRECTORY>(GetProcAddress(hKernel32, "GetSystemWindowsDirectoryW"));
#else
    m_lpfnModule32First = reinterpret_cast<LPMODULE32FIRST>(GetProcAddress(hKernel32, "Module32First"));
    m_lpfnModule32Next  = reinterpret_cast<LPMODULE32NEXT>(GetProcAddress(hKernel32, "Module32Next"));
    m_lpfnProcess32First = reinterpret_cast<LPPROCESS32FIRST>(GetProcAddress(hKernel32, "Process32First"));
    m_lpfnProcess32Next = reinterpret_cast<LPPROCESS32NEXT>(GetProcAddress(hKernel32, "Process32Next"));
    m_lpfnGetSystemWow64Directory = reinterpret_cast<LPGETSYSTEMWOW64DIRECTORY>(GetProcAddress(hKernel32, "GetSystemWow64DirectoryA"));
    m_lpfnGetSystemWindowsDirectory = reinterpret_cast<LPGETSYSTEMWINDOWSDIRECTORY>(GetProcAddress(hKernel32, "GetSystemWindowsDirectoryA"));
#endif
    m_lpfnGlobalMemoryStatusEx = reinterpret_cast<LPGLOBALMEMORYSTATUSEX>(GetProcAddress(hKernel32, "GlobalMemoryStatusEx"));
    m_lpfnIsWow64Process = reinterpret_cast<LPISWOW64PROCESS>(GetProcAddress(hKernel32, "IsWow64Process"));
    m_lpfnGetProcessHandleCount = reinterpret_cast<LPGETPROCESSHANDLECOUNT>(GetProcAddress(hKernel32, "GetProcessHandleCount"));
    m_lpfnProcessIdToSessionId = reinterpret_cast<LPPROCESSIDTOSESSIONID>(GetProcAddress(hKernel32, "ProcessIdToSessionId"));
    m_lpfnGetNativeSystemInfo = reinterpret_cast<LPGETNATIVESYSTEMINFO>(GetProcAddress(hKernel32, "GetNativeSystemInfo"));
    m_lpfnIsProcessorFeaturePresent = reinterpret_cast<LPISPROCESSORFEATUREPRESENT>(GetProcAddress(hKernel32, "IsProcessorFeaturePresent"));
  }
  
  //If any Thread or Module enumeration function pointer NULL, then set them all to NULL. Helps simplify the code which uses the function pointers
  if (m_lpfnCreateToolhelp32Snapshot == NULL || m_lpfnThread32First == NULL || m_lpfnThread32Next == NULL || 
      m_lpfnModule32First == NULL || m_lpfnModule32Next == NULL || m_lpfnProcess32First == NULL || m_lpfnProcess32Next == NULL)
    ResetToolHelpFunctionPointers();

  //Load up the DbgHelp function pointers
  m_hDbgHelp = LoadLibrary(_T("DBGHELP.DLL"));
  if (m_hDbgHelp)
  {
    m_lpfnSymCleanup = reinterpret_cast<LPSYMCLEANUP>(GetProcAddress(m_hDbgHelp, "SymCleanup"));
    m_lpfnSymEnumSymbols = reinterpret_cast<LPSYMENUMSYMBOLS>(GetProcAddress(m_hDbgHelp, "SymEnumSymbols"));
    m_lpfnSymSetOptions = reinterpret_cast<LPSYMSETOPTIONS>(GetProcAddress(m_hDbgHelp, "SymSetOptions"));
    m_lpfnSymInitialize = reinterpret_cast<LPSYMINITIALIZE>(GetProcAddress(m_hDbgHelp, "SymInitialize"));
    m_lpfnSymSetContext = reinterpret_cast<LPSYMSETCONTEXT>(GetProcAddress(m_hDbgHelp, "SymSetContext"));
    m_lpfnSymGetLineFromAddr64 = reinterpret_cast<LPSYMGETLINEFROMADDR64>(GetProcAddress(m_hDbgHelp, "SymGetLineFromAddr64"));
    m_lpfnSymFromAddr = reinterpret_cast<LPSYMFROMADDR>(GetProcAddress(m_hDbgHelp, "SymFromAddr"));
    m_lpfnStackWalk64 = reinterpret_cast<LPSTACKWALK64>(GetProcAddress(m_hDbgHelp, "StackWalk64"));
    m_lpfnSymFunctionTableAccess64 = reinterpret_cast<LPSYMFUNCTIONTABLEACCESS64>(GetProcAddress(m_hDbgHelp, "SymFunctionTableAccess64"));
    m_lpfnSymGetModuleBase64 = reinterpret_cast<LPSYMGETMODULEBASE64>(GetProcAddress(m_hDbgHelp, "SymGetModuleBase64"));
    m_lpfnSymGetTypeInfo = reinterpret_cast<LPSYMGETTYPEINFO>(GetProcAddress(m_hDbgHelp, "SymGetTypeInfo"));
    m_lpfnMiniDumpWriteDump = reinterpret_cast<LPMINIDUMPWRITEDUMP>(GetProcAddress(m_hDbgHelp, "MiniDumpWriteDump"));
  }
  
  //Any function pointer NULL, then set them all to NULL. Helps simplify the code which 
  //uses the function pointers
  if (m_lpfnSymCleanup == NULL || m_lpfnSymEnumSymbols == NULL || m_lpfnSymSetOptions == NULL || m_lpfnSymInitialize == NULL || m_lpfnSymSetContext == NULL ||
      m_lpfnSymGetLineFromAddr64 == NULL || m_lpfnSymFromAddr == NULL || m_lpfnStackWalk64 == NULL || m_lpfnSymFunctionTableAccess64 == NULL || 
      m_lpfnSymGetModuleBase64 == NULL ||m_lpfnSymGetTypeInfo == NULL)
    ResetDbgHelpFunctionPointers();

  //Load up the User32 function pointers
  HMODULE hUser32 = GetModuleHandle(_T("USER32.DLL"));
  if (hUser32)
    m_lpfnGetGuiResources = reinterpret_cast<LPGETGUIRESOURCES>(GetProcAddress(hUser32, "GetGuiResources"));
  else
    m_lpfnGetGuiResources = NULL;

  //Load up the Psapi function pointers
  m_hPsapi = LoadLibrary(_T("PSAPI.DLL"));
  if (m_hPsapi)
  {
    m_lpfnGetProcessMemoryInfo = reinterpret_cast<LPGETPROCESSMEMORYINFO>(GetProcAddress(m_hPsapi, "GetProcessMemoryInfo"));
    m_lpfnGetPerformanceInfo = reinterpret_cast<LPGETPERFORMANCEINFO>(GetProcAddress(m_hPsapi, "GetPerformanceInfo"));
  }

  //Load up the WTS function pointers
  m_hWtsApi32 = LoadLibrary(_T("Wtsapi32.dll"));
  if (m_hWtsApi32)
  {
    m_lpfnWTSGetActiveConsoleSessionId = reinterpret_cast<LPWTSGETACTIVECONSOLESESSIONID>(GetProcAddress(m_hWtsApi32, "WTSGetActiveConsoleSessionId"));
    m_lpfnWTSFreeMemory = reinterpret_cast<LPWTSFREEMEMORY>(GetProcAddress(m_hWtsApi32, "WTSFreeMemory"));
    #ifdef _UNICODE
      m_lpfnWTSQuerySessionInformation = reinterpret_cast<LPWTSQUERYSESSIONINFORMATION>(GetProcAddress(m_hWtsApi32, "WTSQuerySessionInformationW"));
    #else
      m_lpfnWTSQuerySessionInformation = reinterpret_cast<LPWTSQUERYSESSIONINFORMATION>(GetProcAddress(m_hWtsApi32, "WTSQuerySessionInformationA"));
    #endif
  }

  //Load up the Advapi32 function pointers
  m_hAdvapi32 = LoadLibrary(_T("ADVAPI32.DLL"));
  if (m_hAdvapi32)
  {
    #ifdef _UNICODE
      m_lpfnGetCurrentHwProfile = reinterpret_cast<LPGETCURRENTHWPROFILE>(GetProcAddress(m_hAdvapi32, "GetCurrentHwProfileW"));
    #else
      m_lpfnGetCurrentHwProfile = reinterpret_cast<LPGETCURRENTHWPROFILE>(GetProcAddress(m_hAdvapi32, "GetCurrentHwProfileA"));
    #endif
  }

  //By default use the temp directory for our log and minidump files
//   TCHAR szTemp[_MAX_PATH];
//   szTemp[0] = _T('\0');
//   GetTempPath(_MAX_PATH, szTemp);
//   SetDirectory(szTemp);

  //Form the key name to open in the registry
  TCHAR szModule[_MAX_PATH];
  szModule[0] = _T('\0');
  GetModuleFileName(NULL, szModule, _MAX_PATH);
  TCHAR szPath[_MAX_PATH];
  TCHAR szFname[_MAX_FNAME];
  TCHAR szExt[_MAX_EXT];
#if (_MSC_VER >= 1400)
  _tsplitpath_s(szModule, NULL, 0, NULL, 0, szFname, sizeof(szFname)/sizeof(TCHAR), szExt, sizeof(szExt)/sizeof(TCHAR));
  _tmakepath_s(szPath, sizeof(szPath)/sizeof(TCHAR), NULL, NULL, szFname, szExt);
#else  
  _tsplitpath(szModule, NULL, NULL, szFname, szExt);
  _tmakepath(szPath, NULL, NULL, szFname, szExt);
#endif

  TCHAR sKeyName[256];
#if (_MSC_VER >= 1400)
  _stprintf_s(sKeyName, sizeof(sKeyName)/sizeof(TCHAR), _T("SOFTWARE\\PJ Naughter\\XCPTHLR\\%s"), szPath);
#else  
  _stprintf(sKeyName, _T("SOFTWARE\\PJ Naughter\\XCPTHLR\\%s"), szPath);
#endif
  HKEY hKey = NULL;
  LONG nError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, sKeyName, 0, KEY_READ, &hKey);
  if (nError == ERROR_SUCCESS) 
  {
    //Read in the flags settings
    DWORD dwType = 0;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwFlags = 0;
    LONG lResult = RegQueryValueEx(hKey, _T("Flags"), 0, &dwType, reinterpret_cast<LPBYTE>(&dwFlags), &dwSize);
    if (lResult == ERROR_SUCCESS)
      m_dwFlags = dwFlags;

    //Read in the name of the log file 
    dwSize = 0;
  	lResult = RegQueryValueEx(hKey, _T("LogFile"), NULL, &dwType, NULL, &dwSize);
	  if (lResult == ERROR_SUCCESS)
	  {
      dwSize = sizeof(m_szLogFilename);
		  RegQueryValueEx(hKey, _T("LogFile"), NULL, &dwType, reinterpret_cast<LPBYTE>(m_szLogFilename), &dwSize);
    }

    //Remeber to close the key
    RegCloseKey(hKey);
  }

  //Install our exception handler before we return
  m_pPreviousFilter = SetUnhandledExceptionFilter(UnHandledExceptionFilter);
}

void CExceptionLogger::SetDirectory(LPCTSTR pszDirectory)
{
#if (_MSC_VER >= 1400)
  _tcscpy_s(m_szDirectory, sizeof(m_szDirectory)/sizeof(TCHAR), pszDirectory);
#else
  _tcscpy(m_szDirectory, pszDirectory);
#endif

  //Remove any trailing splash if necessary
  size_t nSize = _tcslen(m_szDirectory);
  if (m_szDirectory[nSize - 1] == _T('\\'))
    m_szDirectory[nSize - 1] = _T('\0');
}

void CExceptionLogger::ResetToolHelpFunctionPointers()
{
  m_lpfnCreateToolhelp32Snapshot = NULL;
  m_lpfnThread32First = NULL;
  m_lpfnThread32Next = NULL;
  m_lpfnModule32First = NULL;
  m_lpfnModule32Next = NULL;
  m_lpfnProcess32First = NULL;
  m_lpfnProcess32Next = NULL;
}

void CExceptionLogger::ResetDbgHelpFunctionPointers()
{
  m_lpfnSymCleanup = NULL;
  m_lpfnSymEnumSymbols = NULL;
  m_lpfnSymSetOptions = NULL;
  m_lpfnSymInitialize = NULL;
  m_lpfnSymSetContext = NULL;
  m_lpfnSymGetLineFromAddr64 = NULL;
  m_lpfnSymFromAddr = NULL;
  m_lpfnStackWalk64 = NULL;
  m_lpfnSymFunctionTableAccess64 = NULL;
  m_lpfnSymGetModuleBase64 = NULL;
  m_lpfnSymGetTypeInfo = NULL;
  m_lpfnMiniDumpWriteDump = NULL;
  if (m_hDbgHelp)
  {
    FreeLibrary(m_hDbgHelp);
    m_hDbgHelp = NULL;
  }
}

void CExceptionLogger::ResetWTSFunctionPointers()
{
  m_lpfnWTSGetActiveConsoleSessionId = NULL;
  m_lpfnWTSQuerySessionInformation = NULL;
  m_lpfnWTSFreeMemory = NULL;
  if (m_hWtsApi32)
  { 
    FreeLibrary(m_hWtsApi32);
    m_hWtsApi32 = NULL;
  }
}

void CExceptionLogger::ResetPsapiFunctionPointers()
{
  m_lpfnGetProcessMemoryInfo = NULL;
  m_lpfnGetPerformanceInfo = NULL;
  if (m_hPsapi)
  {
    FreeLibrary(m_hPsapi);
    m_hPsapi = NULL;
  }
}

void CExceptionLogger::ResetAdvapi32FunctionPointers()
{
  m_lpfnGetCurrentHwProfile = NULL;
  if (m_hAdvapi32)
  {
    FreeLibrary(m_hAdvapi32);
    m_hAdvapi32 = NULL;
  }
}

CExceptionLogger::~CExceptionLogger()
{
  //Free up the function pointers
  ResetToolHelpFunctionPointers();
  ResetDbgHelpFunctionPointers();
  ResetWTSFunctionPointers();
  ResetPsapiFunctionPointers();
  ResetAdvapi32FunctionPointers();

  //Restore the old exception handler
  SetUnhandledExceptionFilter(m_pPreviousFilter);
}

void CExceptionLogger::FormFileNames()
{
  //Get the local time for the time stamp
  SYSTEMTIME st;
  GetLocalTime(&st);

  //Form the filename and extension of the current exe
  TCHAR szModule[_MAX_PATH];
  szModule[0] = _T('\0');
  GetModuleFileName(NULL, szModule, _MAX_PATH);
  TCHAR szFname[_MAX_FNAME];
  TCHAR szExt[_MAX_EXT];
#if (_MSC_VER >= 1400)
  _tsplitpath_s(szModule, NULL, 0, NULL, 0, szFname, sizeof(szFname)/sizeof(TCHAR), szExt, sizeof(szExt)/sizeof(TCHAR));
#else  
  _tsplitpath(szModule, NULL, NULL, szFname, szExt);
#endif

  //Form the filenames for the logging and minidump files
#if (_MSC_VER >= 1400)
  _stprintf_s(m_szLogFilename, _MAX_PATH, _T("%s.%04d%02d%02d%02d%02d%02d%03d.exception"), szModule, static_cast<int>(st.wYear), static_cast<int>(st.wMonth),
              static_cast<int>(st.wDay), static_cast<int>(st.wHour), static_cast<int>(st.wMinute), static_cast<int>(st.wSecond),
              static_cast<int>(st.wMilliseconds));
  _stprintf_s(m_szMiniDumpFilename, _MAX_PATH, _T("%s.%04d%02d%02d%02d%02d%02d%03d.dmp"), szModule, static_cast<int>(st.wYear), static_cast<int>(st.wMonth),
              static_cast<int>(st.wDay), static_cast<int>(st.wHour), static_cast<int>(st.wMinute), static_cast<int>(st.wSecond),
              static_cast<int>(st.wMilliseconds));
#else  
  _stprintf(m_szLogFilename, _T("%s.%04d%02d%02d%02d%02d%02d%03d.exception"), szModule, static_cast<int>(st.wYear), static_cast<int>(st.wMonth),
            static_cast<int>(st.wDay), static_cast<int>(st.wHour), static_cast<int>(st.wMinute), static_cast<int>(st.wSecond),
            static_cast<int>(st.wMilliseconds));
  _stprintf(m_szMiniDumpFilename, _T("%s.%04d%02d%02d%02d%02d%02d%03d.dmp"), szModule, static_cast<int>(st.wYear), static_cast<int>(st.wMonth),
            static_cast<int>(st.wDay), static_cast<int>(st.wHour), static_cast<int>(st.wMinute), static_cast<int>(st.wSecond),
            static_cast<int>(st.wMilliseconds));
#endif
}

long CExceptionLogger::UnHandledExceptionFilter(EXCEPTION_POINTERS* pExceptionInfo)
{
  //Form the filenames for the dump files
  FormFileNames();

  //Generate the Minidump if necessary
  if (m_dwFlags & EXCEPTION_LOGGER_MINIDUMP)
    GenerateMiniDump(pExceptionInfo);

  //Open up the log file, Notice we optioanlly use FILE_FLAG_WRITE_THROUGH to avoid caching of writes. That way if our code 
  //goes belly up, we will at least have all the data up to then safely written to disk
  m_hLogFile = CreateFile(m_szLogFilename, GENERIC_WRITE, FILE_SHARE_READ, 0, OPEN_ALWAYS, (m_dwFlags & EXCEPTION_LOGGER_FILE_BUFFERING) ? FILE_ATTRIBUTE_NORMAL : FILE_FLAG_WRITE_THROUGH, 0);
  if (m_hLogFile != INVALID_HANDLE_VALUE)
  {
    //Let the helper function do its job
    GenerateCrashLog(pExceptionInfo);

    //Close the file now that we are finished with it
    CloseHandle(m_hLogFile);
    m_hLogFile = INVALID_HANDLE_VALUE;
  }

  //Chain to the previous exception if there is one
  if (m_pPreviousFilter)
    return m_pPreviousFilter(pExceptionInfo);
  else
    return EXCEPTION_CONTINUE_SEARCH;
}

void CExceptionLogger::GenerateMiniDump(EXCEPTION_POINTERS* pExceptionInfo)
{
  //Only up the dump file and then call MiniDumpWriteDump if available
  HANDLE hDumpFile = CreateFile(m_szMiniDumpFilename, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_WRITE|FILE_SHARE_READ, 0, CREATE_ALWAYS, 0, 0);
  if (hDumpFile != INVALID_HANDLE_VALUE && m_lpfnMiniDumpWriteDump)
  {
    MINIDUMP_EXCEPTION_INFORMATION ExpParam;
    ExpParam.ThreadId = GetCurrentThreadId();
    ExpParam.ExceptionPointers = pExceptionInfo;
    ExpParam.ClientPointers = TRUE;

    m_lpfnMiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hDumpFile, (MINIDUMP_TYPE) (MiniDumpWithFullMemory | MiniDumpWithFullMemoryInfo | MiniDumpWithHandleData | MiniDumpWithThreadInfo | MiniDumpWithUnloadedModules), &ExpParam, NULL, NULL);
  }
}

void CExceptionLogger::GenerateCrashLog(EXCEPTION_POINTERS* pExceptionInfo)
{
  //Write out a banner first to separate multiple log entries
  Log(_T("-----------------------------------------------------\r\n"));

  //get the current time so that it goes into the file
  SYSTEMTIME st;
  GetLocalTime(&st);
  Log(_T("Time of Exception: %02d:%02d:%02d.%03d %d/%d/%d (D/M/Y)\r\n"), st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, st.wDay, st.wMonth, st.wYear);

  //Log the type of unhandled exception
  Log(_T("Exception Code: 0x%08X\r\n"), pExceptionInfo->ExceptionRecord->ExceptionCode);

  //Display extra info if an Access Violation
  if (pExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)
  {
    if (pExceptionInfo->ExceptionRecord->NumberParameters > 0)
    {
      if (pExceptionInfo->ExceptionRecord->ExceptionInformation[0] == 0)
        Log(_T("Access Violation Exception: Due to the thread attempting to read from an inaccessible address\r\n"));
      else
        Log(_T("Access Violation Exception: Due to the thread attempting to write to an inaccessible address\r\n"));
    }
    if (pExceptionInfo->ExceptionRecord->NumberParameters > 1)
    {
    #ifdef _WIN64
      Log(_T("Access Violation Address: 0x%.16I64IX\r\n"), pExceptionInfo->ExceptionRecord->ExceptionInformation[1]);
    #else
      Log(_T("Access Violation Address: 0x%08X\r\n"), pExceptionInfo->ExceptionRecord->ExceptionInformation[1]);
    #endif
    }
  }

  //Is the exception continuable
  if (pExceptionInfo->ExceptionRecord->ExceptionFlags == 0)
    Log(_T("Exception is continuable\r\n"));
  else
    Log(_T("Exception is noncontinuable\r\n"));

  //Log where the fault occurred
  DWORD dwOffset;
  char pszSectionName[IMAGE_SIZEOF_SHORT_NAME+1];
  if (GetAddressDetails(pExceptionInfo->ExceptionRecord->ExceptionAddress, m_szTempFileName, dwOffset, pszSectionName))
  {
    #ifdef _WIN64
      Log(_T("Exception Address Details: 0x%.16I64IX [%hs]:0x%08X %s\r\n"), pExceptionInfo->ExceptionRecord->ExceptionAddress, pszSectionName, dwOffset, m_szTempFileName);
    #else
      Log(_T("Exception Address Details: 0x%08X [%hs]:0x%08X %s\r\n"), pExceptionInfo->ExceptionRecord->ExceptionAddress, pszSectionName, dwOffset, m_szTempFileName);
    #endif
  }
  else
  {
    //Fall back to just reporting the linear faulting address, rather than the additional details
    #ifdef _WIN64
      Log(_T("Exception Address Details: 0x%.16I64IX [UNKNOWN]\r\n"), pExceptionInfo->ExceptionRecord->ExceptionAddress);
    #else
      Log(_T("Exception Address Details: 0x%08X [UNKNOWN]\r\n"), pExceptionInfo->ExceptionRecord->ExceptionAddress);
    #endif
  }

  //Write out the full path to the process which is affected
  GetModuleFileName(NULL, m_szTempFileName, _MAX_PATH);
  Log(_T("Process Path: %s\r\n"), m_szTempFileName);

  //Get the current working directory
  GetCurrentDirectory(_MAX_PATH, m_szTempFileName);
  Log(_T("Current Directory: %s\r\n"), m_szTempFileName);

  //Get the current working directory
  Log(_T("Command Line: %s\r\n"), GetCommandLine());

  //Write out the Process and Thread ID 
  DWORD dwProcessID = GetCurrentProcessId();
  Log(_T("Process ID: %u\r\n"), dwProcessID);
  Log(_T("Thread ID where exception has occurred: 0x%08X\r\n\r\n"), GetCurrentThreadId());

  //Write out the system details
  if (m_dwFlags & EXCEPTION_LOGGER_SYSTEM_DETAILS)
    LogSystemDetails();

  if (m_dwFlags & EXCEPTION_LOGGER_ENVIRONMENT_STRINGS)
    LogEnvironmentStrings();

  //Initialize DBGHELP
  HANDLE hProcess = GetCurrentProcess();
  BOOL bInitDBGHelp = FALSE;
  if (m_hDbgHelp)
  {
    bInitDBGHelp = m_lpfnSymInitialize(hProcess, NULL, TRUE);
    if (!bInitDBGHelp)
      Log(_T(" Failed to initialize Debug Help Library, Error:%d\r\n"), GetLastError());
    m_lpfnSymSetOptions(SYMOPT_DEFERRED_LOADS);
  }
  else
    Log(_T("\r\nCould not load up correct version of Debug Help library\r\n"));

  //Log details on each module in this process
  if ((m_dwFlags & EXCEPTION_LOGGER_ENUMERATE_MODULES) || (m_dwFlags & EXCEPTION_LOGGER_ENUMERATE_THREADS) || (m_dwFlags & EXCEPTION_LOGGER_ENUMERATE_PROCESSES))
  {
    HANDLE hToolHelp32Snap = INVALID_HANDLE_VALUE;
    if (m_lpfnCreateToolhelp32Snapshot)
    {
      hToolHelp32Snap = m_lpfnCreateToolhelp32Snapshot(TH32CS_SNAPALL, 0);
      if (hToolHelp32Snap != INVALID_HANDLE_VALUE) 
      {
        //Log all the processes currently running
        if (m_dwFlags & EXCEPTION_LOGGER_ENUMERATE_PROCESSES)
          LogProcessDetails(hToolHelp32Snap);

        //Log all the threads in the current process 
        if (m_dwFlags & EXCEPTION_LOGGER_ENUMERATE_THREADS)
          LogThreadDetails(hToolHelp32Snap, dwProcessID);

        //Log all the modules in the current process 
        if (m_dwFlags & EXCEPTION_LOGGER_ENUMERATE_MODULES)
          LogModuleDetails(hToolHelp32Snap, dwProcessID, bInitDBGHelp, hProcess);

        //close the handle now that we are finished with it
        CloseHandle(hToolHelp32Snap); 
      }
      else
        Log(_T(" Failed in call to CreateToolhelp32Snapshot, Error:%d\r\n"), GetLastError());
    }
    else
      Log(_T("Processes / Threads / Modules: ToolHelp32 not availble. Cannot enumerate processes, threads or modules\r\n"));
  }

  //Next thing to log is the Registers
  if (m_dwFlags & EXCEPTION_LOGGER_REGISTERS)
    LogRegisters(pExceptionInfo);

  //Next do the call stack
  if (m_dwFlags & EXCEPTION_LOGGER_CALLSTACK)
  {
    if (bInitDBGHelp)
      LogStack(pExceptionInfo->ContextRecord, hProcess);
    else
      Log(_T("\r\nCall Stack: Debug Help not availble. Cannot display stack details\r\n"));
  }

  //Cleanup our usage of DBGHELP
  if (bInitDBGHelp)
    m_lpfnSymCleanup(hProcess);
}

//A Helper function to allow use of sprintf style logging to the crash log file.
//Please note that the file will be Unicode if you build using UNICODE.
int CExceptionLogger::Log(const TCHAR* format, ...)
{
  //Generate the line
  va_list args;
  va_start(args, format);
#if (_MSC_VER >= 1400)
  int nLen = _vstprintf_s(m_szTempLogLine, sizeof(m_szTempLogLine)/sizeof(TCHAR), format, args); //Note that we are using the C runtime here!!
#else  
  int nLen = _vstprintf(m_szTempLogLine, format, args); //Note that we are using the C runtime here!!
#endif
  va_end(args);

  //write the line to disk
  DWORD dwWritten = 0;
  WriteFile(m_hLogFile, m_szTempLogLine, nLen*sizeof(TCHAR), &dwWritten, NULL);
  return nLen;
}

void CExceptionLogger::LogEnvironmentStrings()
{
  Log(_T("Environment Strings:\r\n"));

  LPTSTR lpEnvironment = GetEnvironmentStrings();
  LPTSTR lpString = lpEnvironment;
  while (*lpString)
  {
    Log(_T(" %s\r\n"), lpString);
    lpString += (lstrlen(lpString) + 1);
  }
  FreeEnvironmentStrings(lpEnvironment);
  Log(_T("\r\n"));
}

void CExceptionLogger::LogSystemDetails()
{
  Log(_T("System Details:\r\n"));

  //Computer and User name
  TCHAR szBuffer[4096];
  DWORD dwBuffer = 4096;
  if (GetComputerName(szBuffer, &dwBuffer))
    Log(_T(" Computer Name: %s\r\n"), szBuffer);
  else
    Log(_T(" Computer Name: [UNKNOWN]\r\n"));
  dwBuffer = 4096;
  if (GetUserName(szBuffer, &dwBuffer))
    Log(_T(" User Name: %s\r\n"), szBuffer);
  else
    Log(_T(" User Name: [UNKNOWN]\r\n"));

  //General System info
  SYSTEM_INFO si;
  GetSystemInfo(&si);
  Log(_T(" System information: Using GetSystemInfo\r\n"));
  Log(_T("  Number of Processors: %d\r\n"), si.dwNumberOfProcessors);
  Log(_T("  Page size: %d bytes\r\n"), si.dwPageSize);
#ifdef _WIN64
  Log(_T("  Lowest Memory Address: 0x%.16I64IX\r\n"), si.lpMinimumApplicationAddress);
  Log(_T("  Highest Memory Address: 0x%.16I64IX\r\n"), si.lpMaximumApplicationAddress);
#else
  Log(_T("  Lowest Memory Address: 0x%08X\r\n"), si.lpMinimumApplicationAddress);
  Log(_T("  Highest Memory Address: 0x%08X\r\n"), si.lpMaximumApplicationAddress);
#endif

  //Memory Status
  BOOL bGlobalMemoryStatusEx = FALSE;
  if (m_lpfnGlobalMemoryStatusEx)
  {
    MEMORYSTATUSEX mse;
    mse.dwLength = sizeof(mse);
    bGlobalMemoryStatusEx = m_lpfnGlobalMemoryStatusEx(&mse);
    if (bGlobalMemoryStatusEx)
    {
      Log(_T(" Global Memory Status: Using GlobalMemoryStatusEx\r\n"));
      Log(_T("  Memory Load: %d\r\n"), mse.dwMemoryLoad);
      Log(_T("  Physical Memory: %I64d Kbytes\r\n"), mse.ullTotalPhys/1024);
      Log(_T("  Physical Memory (available): %I64d Kbytes\r\n"), mse.ullAvailPhys/1024);
      Log(_T("  Page File: %I64d kbytes\r\n"), mse.ullTotalPageFile/1024);
      Log(_T("  Page File (available): %I64d Kbytes\r\n"), mse.ullAvailPageFile/1024);
      Log(_T("  Virtual Memory: %I64d Kbytes\r\n"), mse.ullTotalVirtual/1024);
      Log(_T("  Virtual Memory (available): %I64d Kbytes\r\n"), mse.ullAvailVirtual/1024);
    }
  }
  if (!bGlobalMemoryStatusEx)
  {
    MEMORYSTATUS ms;
    GlobalMemoryStatus(&ms);
    Log(_T(" Global Memory Status: Using GlobalMemoryStatus\r\n"));
    Log(_T("  Memory Load: %d\r\n"), ms.dwMemoryLoad);
    Log(_T("  Physical Memory: %d Kbytes\r\n"), ms.dwTotalPhys/1024);
    Log(_T("  Physical Memory (available): %d Kbytes\r\n"), ms.dwAvailPhys/1024);
    Log(_T("  Page File: %d Kbytes\r\n"), ms.dwTotalPageFile/1024);
    Log(_T("  Page File (available): %d Kbytes\r\n"), ms.dwAvailPageFile/1024);
    Log(_T("  Virtual Memory: %d Kbytes\r\n"), ms.dwTotalVirtual/1024);
    Log(_T("  Virtual Memory (available): %d Kbytes\r\n"), ms.dwAvailVirtual/1024);
  }

  if (m_lpfnGetPerformanceInfo)
  {
    PERFORMANCE_INFORMATION pi;
    if (m_lpfnGetPerformanceInfo(&pi, sizeof(pi)))
    {
      Log(_T(" Performance information : Using GetPerformanceInfo\r\n"));
    #ifdef _WIN64
      Log(_T("  Total number of pages commited by the system: %I64d\r\n"), pi.CommitTotal);
      Log(_T("  Current maximum number of page commits that can be performed by the system: %I64d\r\n"), pi.CommitLimit);
      Log(_T("  Maximum number of page commit totals that have occured since last reboot: %I64d\r\n"), pi.CommitPeak);
      Log(_T("  Total amount of physical memory, in pages: %I64d\r\n"), pi.PhysicalTotal);
      Log(_T("  Total amount of physical memory available to user processes, in pages: %I64d\r\n"), pi.PhysicalAvailable);
      Log(_T("  Total amount of system cache memory, in pages: %I64d\r\n"), pi.SystemCache);
      Log(_T("  Total amount of the sum of paged and nonpaged kernel pools, in pages: %I64d\r\n"), pi.KernelTotal);
      Log(_T("  Total amount of paged kernel memory pool, in pages: %I64d\r\n"), pi.KernelPaged);
      Log(_T("  Total amount of nonpaged kernel pool, in pages: %I64d\r\n"), pi.KernelNonpaged);
      Log(_T("  Page Size: %u bytes\r\n"), pi.PageSize);
    #else
      Log(_T("  Total number of pages commited by the system: %d\r\n"), pi.CommitTotal);
      Log(_T("  Current maximum number of page commits that can be performed by the system: %d\r\n"), pi.CommitLimit);
      Log(_T("  Maximum number of page commit totals that have occured since last reboot: %d\r\n"), pi.CommitPeak);
      Log(_T("  Total amount of physical memory, in pages: %d\r\n"), pi.PhysicalTotal);
      Log(_T("  Total amount of physical memory available to user processes, in pages: %d\r\n"), pi.PhysicalAvailable);
      Log(_T("  Total amount of system cache memory, in pages: %d\r\n"), pi.SystemCache);
      Log(_T("  Total amount of the sum of paged and nonpaged kernel pools, in pages: %d\r\n"), pi.KernelTotal);
      Log(_T("  Total amount of paged kernel memory pool, in pages: %d\r\n"), pi.KernelPaged);
      Log(_T("  Total amount of nonpaged kernel pool, in pages: %d\r\n"), pi.KernelNonpaged);
      Log(_T("  Page Size: %u bytes\r\n"), pi.PageSize);
    #endif
      Log(_T("  Total number of open handles: %u\r\n"), pi.HandleCount);
      Log(_T("  Total number of processes: %u\r\n"), pi.ProcessCount);
      Log(_T("  Total number of threads: %u\r\n"), pi.ThreadCount);
    }
  }

  //Per Process memory info from GetProcessMemoryInfo
  HANDLE hThisProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
  if (m_lpfnGetProcessMemoryInfo)
  {
    //Try using a PROCESS_MEMORY_COUNTERS_EX struct first, and if that fails fall back to a PROCESS_MEMORY_COUNTERS struct
    XCPTHLR_PROCESS_MEMORY_COUNTERS_EX pmcex;
    pmcex.cb = sizeof(pmcex);
    PROCESS_MEMORY_COUNTERS pmc;
    pmc.cb = sizeof(pmc);
    if (m_lpfnGetProcessMemoryInfo(hThisProcess, reinterpret_cast<PPROCESS_MEMORY_COUNTERS>(&pmcex), sizeof(pmcex)))
    {
      Log(_T(" Process Memory Status: Using GetProcessMemoryInfo\r\n"));
      Log(_T("  Page Faults: %u\r\n"), pmcex.PageFaultCount);
      Log(_T("  Peak Working Set Size: %d Kbytes\r\n"), pmcex.PeakWorkingSetSize/1024);
      Log(_T("  Working Set Size: %d Kbytes\r\n"), pmcex.WorkingSetSize/1024);
      Log(_T("  Peak Paged pool usage: %d Kbytes\r\n"), pmcex.QuotaPeakPagedPoolUsage/1024);
      Log(_T("  Paged pool usage: %d Kbytes\r\n"), pmcex.QuotaPagedPoolUsage/1024);
      Log(_T("  Peak Non-paged pool usage: %d Kbytes\r\n"), pmcex.QuotaPeakNonPagedPoolUsage/1024);
      Log(_T("  Non-paged pool usage: %d Kbytes\r\n"), pmcex.QuotaNonPagedPoolUsage/1024);
      Log(_T("  Peak Pagefile usage: %d Kbytes\r\n"), pmcex.PeakPagefileUsage/1024);
      Log(_T("  Pagefile usage: %d Kbytes\r\n"), pmcex.PagefileUsage/1024);
      Log(_T("  Private usage: %d Kbytes\r\n"), pmcex.PrivateUsage/1024);
    }
    else if (m_lpfnGetProcessMemoryInfo(hThisProcess, &pmc, sizeof(pmc)))
    {
      Log(_T(" Process Memory Status: Using GetProcessMemoryInfo\r\n"));
      Log(_T("  Page Faults: %u\r\n"), pmcex.PageFaultCount);
      Log(_T("  Peak Working Set Size: %d Kbytes\r\n"), pmcex.PeakWorkingSetSize/1024);
      Log(_T("  Working Set Size: %d Kbytes\r\n"), pmcex.WorkingSetSize/1024);
      Log(_T("  Peak Paged pool usage: %d Kbytes\r\n"), pmcex.QuotaPeakPagedPoolUsage/1024);
      Log(_T("  Paged pool usage: %d Kbytes\r\n"), pmcex.QuotaPagedPoolUsage/1024);
      Log(_T("  Peak Non-paged pool usage: %d Kbytes\r\n"), pmcex.QuotaPeakNonPagedPoolUsage/1024);
      Log(_T("  Non-paged pool usage: %d Kbytes\r\n"), pmcex.QuotaNonPagedPoolUsage/1024);
      Log(_T("  Peak Pagefile usage: %d Kbytes\r\n"), pmcex.PeakPagefileUsage/1024);
      Log(_T("  Pagefile usage: %d Kbytes\r\n"), pmcex.PagefileUsage/1024);
    }
  }

  //GDI and User object count
  Log(_T(" Object Counts\r\n"));
  if (m_lpfnGetGuiResources)
  {
    Log(_T("  GDI Objects %u\r\n"), m_lpfnGetGuiResources(hThisProcess, GR_GDIOBJECTS));
    Log(_T("  USER Objects %u\r\n"), m_lpfnGetGuiResources(hThisProcess, GR_USEROBJECTS));
  }
  else
    Log(_T("  User32.dll is not loaded, not bothering to report GUI resource usage\r\n"));

  //the process handle count
  DWORD dwHandleCount = 0;
  if (m_lpfnGetProcessHandleCount(hThisProcess, &dwHandleCount))
    Log(_T("  Handle Count: %u\r\n"), dwHandleCount);

  CloseHandle(hThisProcess);

  //Try using the expanded version first, then fall back to the smaller one  
  Log(_T(" OS Version Info\r\n"));
  BOOL bNT4 = FALSE;
  OSVERSIONINFOEX osviex;
  ZeroMemory(&osviex, sizeof(osviex));
  osviex.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
  BOOL bGotOS = GetVersionEx(reinterpret_cast<LPOSVERSIONINFO>(&osviex));
  BOOL bGotOSviEx = bGotOS;
  if (!bGotOS)
  {
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    bGotOS = GetVersionEx(&osvi);
    if (bGotOS)
      memcpy(&osviex, &osvi, sizeof(osvi));
  }
  
  if (bGotOS)
  {
    if (osviex.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
      //Running on the Win9x kernel
      if (osviex.dwMajorVersion == 4 && osviex.dwMinorVersion == 0)
        Log(_T("  Windows 95"));
      else if (osviex.dwMinorVersion == 10)
        Log(_T("  Windows 98")); 
      else
        Log(_T("  Windows ME")); 
    }
    else
    {
      //Running on the NT Kernel
      if (osviex.dwMajorVersion <= 4)
      {
        bNT4 = TRUE;
        if (bGotOSviEx)
        {
          if (osviex.wProductType == VER_NT_DOMAIN_CONTROLLER)
            Log(_T("  NT Server Domain Controller")); 
          else if (osviex.wProductType == VER_NT_SERVER)
            Log(_T("  NT Server")); 
          else
	          Log(_T("  NT Workstation"));
	      }
	      else
	        Log(_T("  NT"));
      }
      else if (osviex.dwMajorVersion == 5 && osviex.dwMinorVersion == 0)
      {
        if (osviex.wProductType == VER_NT_DOMAIN_CONTROLLER)
          Log(_T("  Windows 2000 Domain Controller")); 
        else if (osviex.wProductType == VER_NT_SERVER)
          Log(_T("  Windows 2000 Server")); 
        else
          Log(_T("  Windows 2000 Professional")); 
      }
      else if (osviex.dwMajorVersion == 5)
      {
        BOOL bR2 = GetSystemMetrics(SM_SERVERR2);
        if (osviex.wProductType == VER_NT_DOMAIN_CONTROLLER)
        {
          if (bR2)
            Log(_T("  Windows Server 2003 R2 Domain Controller")); 
          else
            Log(_T("  Windows Server 2003 Domain Controller")); 
        }
        else if (osviex.wProductType == VER_NT_SERVER)
        {
          if (bR2)
            Log(_T("  Windows Server 2003 R2")); 
          else
            Log(_T("  Windows Server 2003")); 
        }
        else
          Log(_T("  Windows XP")); 
      }
      else
      {
        if (osviex.wProductType == VER_NT_DOMAIN_CONTROLLER)
          Log(_T("  Windows Server \"Longhorn\" Domain Controller"));
        else if (osviex.wProductType == VER_NT_SERVER)
          Log(_T("  Windows Server \"Longhorn\""));
        else
          Log(_T("  Windows Vista"));
      }
    }

    #ifdef _WIN64
      Log(_T(" 64bit Edition"));
    #endif

    Log(_T(" v%d.%d\r\n"), osviex.dwMajorVersion, osviex.dwMinorVersion);
    Log(_T("  Current Build: %d\r\n"), LOWORD(osviex.dwBuildNumber));
    Log(_T("  Service Pack: %s\r\n  Suite Information:"), osviex.szCSDVersion);
    
    //Report on all the suite flags
    if (osviex.wSuiteMask & VER_SUITE_SMALLBUSINESS)
      Log(_T(" Microsoft Small Business Server,"));
    if (osviex.wSuiteMask & VER_SUITE_ENTERPRISE)
      Log(_T(" Enterprise Edition,"));
    if (osviex.wSuiteMask & VER_SUITE_TERMINAL)
      Log(_T(" Terminal Services,"));
    if (osviex.wSuiteMask & VER_SUITE_DATACENTER)
      Log(_T(" Datacenter Edition,"));
    if (osviex.wSuiteMask & VER_SUITE_PERSONAL)
      Log(_T(" Home Edition,"));
    if (osviex.wSuiteMask & VER_SUITE_BLADE)
      Log(_T(" Web Edition,"));
    if (osviex.wSuiteMask & VER_SUITE_EMBEDDEDNT)
      Log(_T(" Embedded,"));
    if (osviex.wSuiteMask & VER_SUITE_SINGLEUSERTS)
      Log(_T(" Terminal Services in Remote Admin Mode,"));
    if (osviex.wSuiteMask & VER_SUITE_COMPUTE_SERVER)
      Log(_T(" Compute Cluster Edition,"));
    if (osviex.wSuiteMask & VER_SUITE_STORAGE_SERVER)
      Log(_T(" Storage Server,"));
    if (osviex.wSuiteMask & VER_SUITE_SECURITY_APPLIANCE)
      Log(_T(" Security Appliance,"));
    if (osviex.wSuiteMask & VER_SUITE_BACKOFFICE)
      Log(_T(" Microsoft BackOffice components,"));
    if (GetSystemMetrics(SM_MEDIACENTER))
      Log(_T(" Media Center Edition,"));
    if (GetSystemMetrics(SM_TABLETPC))
      Log(_T(" Tablet Edition,"));
    Log(_T("\r\n"));

    //Get the "Registered To" details
    if (osviex.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
      HKEY hCurrentVersionKey = NULL;
      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"), 0, KEY_READ, &hCurrentVersionKey) == ERROR_SUCCESS)
      {
        DWORD dwBufLen = sizeof(szBuffer) * sizeof(TCHAR);
        if (RegQueryValueEx(hCurrentVersionKey, _T("RegisteredOrganization"), NULL, NULL, reinterpret_cast<LPBYTE>(szBuffer), &dwBufLen) == ERROR_SUCCESS)
          Log(_T("  Registered Organisation: %s\r\n"), szBuffer);

        dwBufLen = sizeof(szBuffer) * sizeof(TCHAR);
        if (RegQueryValueEx(hCurrentVersionKey, _T("RegisteredOwner"), NULL, NULL, reinterpret_cast<LPBYTE>(szBuffer), &dwBufLen) == ERROR_SUCCESS)
          Log(_T("  Registered Owner: %s\r\n"), szBuffer);

        RegCloseKey(hCurrentVersionKey);
      }
    }
  }
  else
    Log(_T("   Unknown Windows version\r\n"));

  //Report on the processor details
  if (m_lpfnIsProcessorFeaturePresent)
  {
    Log(_T(" Processor Features\r\n"));
    if (m_lpfnIsProcessorFeaturePresent(PF_3DNOW_INSTRUCTIONS_AVAILABLE))
      Log(_T("  3D-Now instruction set is available\r\n")); 
    else
      Log(_T("  3D-Now instruction set is not available\r\n")); 
    if (m_lpfnIsProcessorFeaturePresent(PF_COMPARE_EXCHANGE_DOUBLE))
      Log(_T("  The Atomic Compare and Exchange operation (cmpxchg) is available\r\n")); 
    else
      Log(_T("  The Atomic Compare and Exchange operation cmpxchg) is not available\r\n")); 
    if (m_lpfnIsProcessorFeaturePresent(PF_COMPARE_EXCHANGE128))
      Log(_T("  The Atomic Compare and Exchange 128-bit operation (cmpxchg16b) is available\r\n")); 
    else
      Log(_T("  The Atomic Compare and Exchange 128-bit operation (cmpxchg16b) is not available\r\n")); 
    if (m_lpfnIsProcessorFeaturePresent(PF_COMPARE64_EXCHANGE128))
      Log(_T("  The Atomic Compare 64 and Exchange 128-bit operation (cmp8xchg16b) is available\r\n")); 
    else
      Log(_T("  The Atomic Compare 64 and Exchange 128-bit operation (cmp8xchg16) is not available\r\n")); 
    BOOL bFloatingPointEmulated = m_lpfnIsProcessorFeaturePresent(PF_FLOATING_POINT_EMULATED);
    if (bNT4)
      bFloatingPointEmulated = (bFloatingPointEmulated == 0);
    if (bFloatingPointEmulated)
      Log(_T("  Floating-point operations are emulated using software\r\n")); 
    else
      Log(_T("  Floating-point operations are implemented using hardware\r\n")); 
    if (m_lpfnIsProcessorFeaturePresent(PF_FLOATING_POINT_PRECISION_ERRATA))
      Log(_T("  Floating-point precision error can occur in rate circumstances (Pentium FDIV bug)\r\n")); 
    if (m_lpfnIsProcessorFeaturePresent(PF_MMX_INSTRUCTIONS_AVAILABLE))
      Log(_T("  MMX instruction set is available\r\n")); 
    else
      Log(_T("  MMX instruction set is not available\r\n")); 
    if (m_lpfnIsProcessorFeaturePresent(PF_NX_ENABLED))
      Log(_T("  Data execution prevention (DEP) is enabled\r\n")); 
    else
      Log(_T("  Data execution prevention (DEP) is not enabled\r\n")); 
    if (m_lpfnIsProcessorFeaturePresent(PF_PAE_ENABLED))
      Log(_T("  Physical Address Extension is (PAE) enabled\r\n")); 
    else
      Log(_T("  Physical Address Extension is (PAE) not enabled\r\n")); 
    if (m_lpfnIsProcessorFeaturePresent(PF_RDTSC_INSTRUCTION_AVAILABLE))
      Log(_T("  The RDTSC instruction is available\r\n")); 
    else
      Log(_T("  The RDTSC instruction is not available\r\n")); 
    if (m_lpfnIsProcessorFeaturePresent(PF_XMMI_INSTRUCTIONS_AVAILABLE))
      Log(_T("  The SSE instruction set is available\r\n")); 
    else
      Log(_T("  The SSE instruction set is not available\r\n")); 
    if (m_lpfnIsProcessorFeaturePresent(PF_XMMI64_INSTRUCTIONS_AVAILABLE))
      Log(_T("  The SSE2 instruction set is available\r\n")); 
    else
      Log(_T("  The SSE2 instruction set is not available\r\n")); 
    if (m_lpfnIsProcessorFeaturePresent(PF_SSE3_INSTRUCTIONS_AVAILABLE))
      Log(_T("  The SSE3 instruction set is available\r\n")); 
    else
      Log(_T("  The SSE3 instruction set is not available\r\n")); 
  }

  //Report on Wow64
  BOOL bWow64Process = FALSE;
  if (m_lpfnIsWow64Process)
    m_lpfnIsWow64Process(GetCurrentProcess(), &bWow64Process);
  if (bWow64Process)
  {
    Log(_T(" Running on Wow64 emulation layer\r\n"));

    //Also report the native system info if available
    if (m_lpfnGetNativeSystemInfo)
    {
      m_lpfnGetNativeSystemInfo(&si);
      Log(_T("  Native Number of Processors: %d\r\n"), si.dwNumberOfProcessors);
      Log(_T("  Native Page size: %d bytes\r\n"), si.dwPageSize);
    #ifdef _WIN64
      Log(_T("  Native Lowest Memory Address: 0x%.16I64IX\r\n"), si.lpMinimumApplicationAddress);
      Log(_T("  Native Highest Memory Address: 0x%.16I64IX\r\n"), si.lpMaximumApplicationAddress);
    #else
      Log(_T("  Native Lowest Memory Address: %08X\r\n"), si.lpMinimumApplicationAddress);
      Log(_T("  Native Highest Memory Address: %08X\r\n"), si.lpMaximumApplicationAddress);
    #endif
    }

    if (m_lpfnGetSystemWow64Directory)
    {
      if (m_lpfnGetSystemWow64Directory(szBuffer, sizeof(szBuffer)/sizeof(TCHAR)))
        Log(_T("  Wow64 System Directory:%s\r\n"), szBuffer);
    }
  }

  DWORD dwSessionID = 0;
  if (m_lpfnProcessIdToSessionId)
  {
    if (m_lpfnProcessIdToSessionId(GetCurrentProcessId(), &dwSessionID))
      Log(_T(" Session ID: %u\r\n"), dwSessionID);
  }
  else
    Log(_T(" Session ID: [UNKNOWN]\r\n"));

  //report on Terminal services
  if (GetSystemMetrics(SM_REMOTESESSION))
  {
    Log(_T(" Running in a Terminal services environment\r\n"));
      
    if (m_lpfnWTSGetActiveConsoleSessionId)
    {
      DWORD dwActiveConsoleSessionId = m_lpfnWTSGetActiveConsoleSessionId();
      if (dwSessionID == dwActiveConsoleSessionId)
        Log(_T("  Running on the Terminal Services session currently attached to the physical console\r\n"));
      else
        Log(_T("  Not running on the Terminal Services session currently attached to the physical console\r\n"));
    }

    if (m_lpfnWTSQuerySessionInformation && m_lpfnWTSFreeMemory)
    {
      DWORD dwBytesReturned;
      LPTSTR psBuffer;

      //report the published application name
      if (m_lpfnWTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, WTS_CURRENT_SESSION, WTSApplicationName, &psBuffer, &dwBytesReturned))
      {
        if (psBuffer)
          Log(_T("  Published application name: %s\r\n"), psBuffer);
        m_lpfnWTSFreeMemory(psBuffer);  
      }

      //report the client address
      if (m_lpfnWTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, WTS_CURRENT_SESSION, WTSClientAddress, &psBuffer, &dwBytesReturned))
      {
        if (dwBytesReturned >= sizeof(WTS_CLIENT_ADDRESS))
        {
          WTS_CLIENT_ADDRESS* pClientAddress = reinterpret_cast<WTS_CLIENT_ADDRESS*>(psBuffer);          
          Log(_T("  Client address: "));
          Log(_T("Family: %u, Address:"), pClientAddress->AddressFamily);
          for (int j=0; j<sizeof(pClientAddress->Address); j++)
            Log(_T(" %02X"), pClientAddress->Address[j]);
          Log(_T("\r\n"));
        }
        m_lpfnWTSFreeMemory(psBuffer);  
      }

      //report the client build number
      if (m_lpfnWTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, WTS_CURRENT_SESSION, WTSClientBuildNumber, &psBuffer, &dwBytesReturned))
      {
        if (dwBytesReturned >= sizeof(DWORD))
        {
          DWORD* pClientBuildNumber = reinterpret_cast<DWORD*>(psBuffer);          
          Log(_T("  Client build number: %u\r\n"), *pClientBuildNumber);
        }

        m_lpfnWTSFreeMemory(psBuffer);  
      }

      //report the client directory
      if (m_lpfnWTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, WTS_CURRENT_SESSION, WTSClientDirectory, &psBuffer, &dwBytesReturned))
      {
        if (psBuffer)
          Log(_T("  Client Directory: %s\r\n"), psBuffer);
        m_lpfnWTSFreeMemory(psBuffer);  
      }

      //report the client display
      if (m_lpfnWTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, WTS_CURRENT_SESSION, WTSClientDisplay, &psBuffer, &dwBytesReturned))
      {
        if (dwBytesReturned >= sizeof(WTS_CLIENT_DISPLAY))
        {
          WTS_CLIENT_DISPLAY* pClientDisplay = reinterpret_cast<WTS_CLIENT_DISPLAY*>(psBuffer);          
          Log(_T("  Client display width: %u\r\n"), pClientDisplay->HorizontalResolution);
          Log(_T("  Client display height: %u\r\n"), pClientDisplay->VerticalResolution);
          switch (pClientDisplay->ColorDepth)
          {
            case 1: 
            {
              Log(_T("  Client color depth: 16 colors\r\n"));
              break;
            }
            case 2: 
            {
              Log(_T("  Client color depth: 256 colors\r\n"));
              break;
            }
            case 4: 
            {
              Log(_T("  Client color depth: 16 bits per pixel\r\n"));
              break;
            }
            case 8: 
            {
              Log(_T("  Client color depth: 3 bytes per pixel\r\n"));
              break;
            }
            case 16: 
            {
              Log(_T("  Client color depth: 15 bits per pixel\r\n"));
              break;
            }
            default: 
            {
              Log(_T("  Client color depth: Unknown, numeric value:%u\r\n"), pClientDisplay->ColorDepth);
              break;
            }
          }
        }
        m_lpfnWTSFreeMemory(psBuffer);  
      }

      if (m_lpfnWTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, WTS_CURRENT_SESSION, WTSClientHardwareId, &psBuffer, &dwBytesReturned))
      {
        if (dwBytesReturned >= sizeof(DWORD))
        {
          DWORD* pClientHardwareID = reinterpret_cast<DWORD*>(psBuffer);          
          Log(_T("  Client HardwareId: %u\r\n"), *pClientHardwareID);
        }

        m_lpfnWTSFreeMemory(psBuffer);  
      }

      //report the client name
      if (m_lpfnWTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, WTS_CURRENT_SESSION, WTSClientName, &psBuffer, &dwBytesReturned))
      {
        if (psBuffer)
          Log(_T("  Client Name: %s\r\n"), psBuffer);
        m_lpfnWTSFreeMemory(psBuffer);  
      }

      //Report the client product id
      if (m_lpfnWTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, WTS_CURRENT_SESSION, WTSClientProductId, &psBuffer, &dwBytesReturned))
      {
        if (dwBytesReturned >= sizeof(USHORT))
        {
          USHORT* pClientProductId = reinterpret_cast<USHORT*>(psBuffer);          
          Log(_T("  Client product identifier: %d\r\n"), static_cast<int>(*pClientProductId));
        }
        m_lpfnWTSFreeMemory(psBuffer);  
      }

      //Report the client protocol type
      if (m_lpfnWTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, WTS_CURRENT_SESSION, WTSClientProtocolType, &psBuffer, &dwBytesReturned))
      {
        if (dwBytesReturned >= sizeof(USHORT))
        {
          USHORT* pClientProtocolType = reinterpret_cast<USHORT*>(psBuffer);     
          switch (*pClientProtocolType)
          {
            case WTS_PROTOCOL_TYPE_CONSOLE:
            {
              Log(_T("  Client protocol type: Console\r\n"));
              break;
            }
            case WTS_PROTOCOL_TYPE_ICA:
            {
              Log(_T("  Client protocol type: ICA\r\n"));
              break;
            }
            case WTS_PROTOCOL_TYPE_RDP:
            {
              Log(_T("  Client protocol type: RDP\r\n"));
              break;
            }
            default:
            {
              Log(_T("  Client protocol type: Unknown, numeric value:%d\r\n"), static_cast<int>(*pClientProtocolType));
              break;
            }
          }     
        }
        m_lpfnWTSFreeMemory(psBuffer);  
      }

      //Report the domain name
      if (m_lpfnWTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, WTS_CURRENT_SESSION, WTSDomainName, &psBuffer, &dwBytesReturned))
      {
        Log(_T("  Domain name: %s\r\n"), psBuffer);
        m_lpfnWTSFreeMemory(psBuffer);  
      }

      //Report the user name
      if (m_lpfnWTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, WTS_CURRENT_SESSION, WTSUserName, &psBuffer, &dwBytesReturned))
      {
        Log(_T("  User name: %s\r\n"), psBuffer);
        m_lpfnWTSFreeMemory(psBuffer);  
      }

      //Report the window station
      if (m_lpfnWTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, WTS_CURRENT_SESSION, WTSWinStationName, &psBuffer, &dwBytesReturned))
      {
        Log(_T("  Windows Station: %s\r\n"), psBuffer);
        m_lpfnWTSFreeMemory(psBuffer);  
      }

      //Report the working directory
      if (m_lpfnWTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, WTS_CURRENT_SESSION, WTSWorkingDirectory, &psBuffer, &dwBytesReturned))
      {
        Log(_T("  Working Directory: %s\r\n"), psBuffer);
        m_lpfnWTSFreeMemory(psBuffer);  
      }
    }
  }

  //Get the Install type
  HKEY hOsTypeKey = NULL;
  if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"), 0, KEY_READ, &hOsTypeKey) == ERROR_SUCCESS)
  {
    DWORD dwBufLen = sizeof(szBuffer) * sizeof(TCHAR);

    if (::RegQueryValueEx(hOsTypeKey, _T("CurrentType"), NULL, NULL, reinterpret_cast<LPBYTE>(szBuffer), &dwBufLen) == ERROR_SUCCESS)
    {
      if (lstrcmpi(szBuffer, _T("Uniprocessor Free")) == 0)
        Log(_T(" Current Type: Uniprocessor Free\r\n"));         
      else if (lstrcmpi(szBuffer, _T("Uniprocessor Checked")) == 0)
        Log(_T(" Current Type: Uniprocessor Checked\r\n"));         
      else if (lstrcmpi(szBuffer, _T("Multiprocessor Free")) == 0)
        Log(_T(" Current Type: Multiprocessor Free\r\n"));         
      else if (lstrcmpi(szBuffer, _T("Multiprocessor Checked")) == 0)
        Log(_T(" Current Type: Multiprocessor Free\r\n"));         
      else
        Log(_T(" Current Type: [UNKNOWN]\r\n"));         
    }
    RegCloseKey(hOsTypeKey);
  }
  else
    Log(_T(" Current Type: [UNKNOWN]\r\n"));         

  //Windows Directory
  if (GetWindowsDirectory(szBuffer, sizeof(szBuffer)/sizeof(TCHAR)))
    Log(_T(" Windows Directory: %s\r\n"), szBuffer);
  else
    Log(_T(" Windows Directory: [UNKNOWN]\r\n"));

  //Windows System Directory
  if (GetSystemDirectory(szBuffer, sizeof(szBuffer)/sizeof(TCHAR)))
    Log(_T(" System Directory: %s\r\n"), szBuffer);
  else
    Log(_T(" System Directory: [UNKNOWN]\r\n"));

  if (m_lpfnGetSystemWindowsDirectory)
  {
    //Shared Windows System Directory
    if (m_lpfnGetSystemWindowsDirectory(szBuffer, sizeof(szBuffer)/sizeof(TCHAR)))
      Log(_T(" Shared Windows Directory: %s\r\n"), szBuffer);
    else
      Log(_T(" Shared Windows Directory: [UNKNOWN]\r\n"));
  }

  //System Metrics
  int nCleanBoot = GetSystemMetrics(SM_CLEANBOOT);
  switch (nCleanBoot)
  {
    case 0: 
    {
      Log(_T(" Normal Boot\r\n"));
      break;
    }
    case 1:
    {
      Log(_T(" Fail-safe Boot\r\n"));
      break;
    }
    case 2:
    {
      Log(_T(" Fail-safe with network Boot\r\n"));
      break;
    }
    default:
    {
      break;
    }
  }

  int nMonitors = GetSystemMetrics(SM_CMONITORS);
  Log(_T(" Monitors: %d\r\n"), nMonitors);

  int nX = GetSystemMetrics(SM_XVIRTUALSCREEN);
  int nY = GetSystemMetrics(SM_YVIRTUALSCREEN);
  int nCX = GetSystemMetrics(SM_CXVIRTUALSCREEN);
  int nCY = GetSystemMetrics(SM_CYVIRTUALSCREEN);
  Log(_T(" Virtual Screen %d, %d, %d, %d\r\n"), nX, nY, nCX, nCY);

  //Screen DC used to get current display settings
  HDC hdc = GetDC(NULL);  
  if (hdc)
  {
    Log(_T(" Active Display (Bits per Pixel): %d\r\n"), GetDeviceCaps(hdc, BITSPIXEL));
    Log(_T(" Active Display (Width): %d\r\n"), GetDeviceCaps(hdc, HORZRES));
    Log(_T(" Active Display (Height): %d\r\n"), GetDeviceCaps(hdc, VERTRES));
    Log(_T(" Active Display (Refresh Rate): %d\r\n"), GetDeviceCaps(hdc, VREFRESH));
    ReleaseDC(NULL, hdc);
  }
  else
    Log(_T(" Unable to get Active Display setting\r\n"));

  int nButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);
  if (nButtons)
    Log(_T(" Mouse Buttons: %d\r\n"), nButtons);
  else
    Log(_T(" No Mouse installed\r\n"));

  int nNetwork = GetSystemMetrics(SM_NETWORK);
  if (nNetwork & 1)
    Log(_T(" Network present\r\n"));
  else
    Log(_T(" Network not present\r\n"));

  //Report hardware profile details
  if (m_lpfnGetCurrentHwProfile)
  {
    HW_PROFILE_INFO hwpi;
    if (m_lpfnGetCurrentHwProfile(&hwpi))
    {
      Log(_T(" Hardware Profile\r\n"));
      if (hwpi.dwDockInfo & DOCKINFO_DOCKED)
        Log(_T("  Docked, "));
      else if (hwpi.dwDockInfo & DOCKINFO_UNDOCKED)
        Log(_T("  Undocked, "));
      Log(_T("\r\n"));
      Log(_T("  Profile Guid: %s\r\n"), hwpi.szHwProfileGuid);
      Log(_T("  Profile Name: %s\r\n"), hwpi.szHwProfileName);
    }
  }

  UINT nCP = GetACP();
  Log(_T(" ANSI Code Page: %d\r\n"), nCP);
  nCP = GetOEMCP();
  Log(_T(" OEM Code Page: %d\r\n"), nCP);
  LANGID nLangID = GetUserDefaultLangID();
  Log(_T(" User Default Lang ID: %d\r\n"), nLangID);
  nLangID = GetSystemDefaultLangID();
  Log(_T(" System Default Lang ID: %d\r\n"), nLangID);

  LCID nLCID = GetUserDefaultLCID();
  Log(_T(" User Default Locale ID: %d\r\n"), nLCID);
  nLCID = GetSystemDefaultLCID();
  Log(_T(" System Default Locale ID: %d\r\n"), nLCID);

  Log(_T("\r\n"));
}

void CExceptionLogger::LogProcessDetails(HANDLE hToolHelp32Snap)
{
  Log(_T("Processes:\r\n"));

  //Fill in the size of the structure before using it. 
  PROCESSENTRY32 pe32; 
  pe32.dwSize = sizeof(PROCESSENTRY32); 

  //Walk the snapshot of the processes, and for each process, 
  //display information. 
  if (m_lpfnProcess32First(hToolHelp32Snap, &pe32)) 
  {
    do
    {
      Log(_T(" Name: %s\r\n"), pe32.szExeFile);
      Log(_T(" Process ID: %d\r\n"), pe32.th32ProcessID);
      Log(_T(" Threads: %d\r\n"), pe32.cntThreads);
      Log(_T(" Reference Count: %d\r\n"), pe32.cntUsage);
      Log(_T(" Parent Process ID: %d\r\n"), pe32.th32ParentProcessID);

      //Log the file version info for this module
      if (m_dwFlags & EXCEPTION_LOGGER_EXE_VERSION_DETAILS)
        LogFileVersionDetails(pe32.szExeFile);

      Log(_T(" Base Priority: %d\r\n\r\n"), pe32.pcPriClassBase);
    } 
    while (m_lpfnProcess32Next(hToolHelp32Snap, &pe32)); 
  }
  else
    Log(_T(" Failed in call to Process32First, Error:%d\r\n\r\n"), GetLastError());
}

void CExceptionLogger::LogFileVersionDetails(LPCTSTR pszModule)
{
  //Need to make a copy of the string as "GetFileVersionInfoSize"
  //is prototyped as taking a "LPTSTR" not a "LPCTSTR".
  TCHAR szLocalModule[_MAX_PATH];
#if (_MSC_VER >= 1400)
  _tcscpy_s(szLocalModule, sizeof(szLocalModule)/sizeof(TCHAR), pszModule);
#else  
  _tcscpy(szLocalModule, pszModule);
#endif

  DWORD dwHandle = 0;
  DWORD dwSize = GetFileVersionInfoSize(szLocalModule, &dwHandle);
  if (dwSize)
  {
    HLOCAL hVerData = LocalAlloc(LMEM_MOVEABLE, dwSize);
    LPVOID pVerData = LocalLock(hVerData);
    if (GetFileVersionInfo(szLocalModule, dwHandle, dwSize, pVerData))
    {
      //Get the fixed size version info data
      UINT nLen = 0;
      VS_FIXEDFILEINFO* pffi = NULL;
      if (VerQueryValue(pVerData, _T("\\"), reinterpret_cast<LPVOID*>(&pffi), &nLen))
        Log(_T(" File Version: %d.%d.%d.%d\r\n"), HIWORD(pffi->dwFileVersionMS), LOWORD(pffi->dwFileVersionMS), HIWORD(pffi->dwFileVersionLS), LOWORD(pffi->dwFileVersionLS));
    }
    GlobalUnlock(hVerData);
    LocalFree(hVerData);
  }
}

void CExceptionLogger::LogModuleDetails(HANDLE hToolHelp32Snap, DWORD dwProcessID, BOOL bDisplayVariables, HANDLE hProcess)
{
  Log(_T("Modules:\r\n"));

  //Fill in the size of the structure before using it. 
  MODULEENTRY32 me32;
  me32.dwSize = sizeof(MODULEENTRY32); 

  //Walk the thread snapshot to find all threads of the process. 
  //If the thread belongs to the process, add its information 
  //to the display list.
  if (m_lpfnModule32First(hToolHelp32Snap, &me32)) 
  { 
    do 
    { 
      if (me32.th32ProcessID == dwProcessID)
      {
        Log(_T(" Name: %s\r\n"), me32.szModule);
        Log(_T(" Path: %s\r\n"), me32.szExePath);
        Log(_T(" Global Usage Count: %d\r\n"), me32.GlblcntUsage);
        Log(_T(" Process Usage Count: %d\r\n"), me32.ProccntUsage);
      #ifdef _WIN64
        Log(_T(" HMODULE: 0x%.16I64IX\r\n"), me32.modBaseAddr);
      #else  
        Log(_T(" HMODULE: 0x%08X\r\n"), me32.modBaseAddr);
      #endif
        Log(_T(" Size: %d\r\n"), me32.modBaseSize);

        //Also display all the symbols for this module
        if (m_dwFlags & EXCEPTION_LOGGER_MODULE_SYMBOLS)
        {
          if (bDisplayVariables)
          {
            //display all the global variables
            Log(_T(" Variables for this Module\r\n"));
            m_lpfnSymEnumSymbols(hProcess, reinterpret_cast<ULONG64>(me32.modBaseAddr), NULL, EnumSymbols, 0);
          }
          else
            Log(_T(" Variables for this Module: Debug Help dll not availble, Cannot display variable details\r\n"));
        }

        //Log the file version info for this module
        if (m_dwFlags & EXCEPTION_LOGGER_DLL_VERSION_DETAILS)
          LogFileVersionDetails(me32.szExePath);

        Log(_T("\r\n"));
      }
    } 
    while (m_lpfnModule32Next(hToolHelp32Snap, &me32)); 
  } 
  else
    Log(_T(" Failed in call to Module32First, Error:%d\r\n"), GetLastError());
}

void CExceptionLogger::LogRegisters(EXCEPTION_POINTERS* pExceptionInfo)
{
#ifdef _WIN64
  Log(_T("Registers:\r\n RAX    %.16I64IX\r\n"), pExceptionInfo->ContextRecord->Rax);
  Log(_T(" RBX    %.16I64IX\r\n"), pExceptionInfo->ContextRecord->Rbx);
  Log(_T(" RCX    %.16I64IX\r\n"), pExceptionInfo->ContextRecord->Rcx);
  Log(_T(" RDX    %.16I64IX\r\n"), pExceptionInfo->ContextRecord->Rdx);
  Log(_T(" RSI    %.16I64IX\r\n"), pExceptionInfo->ContextRecord->Rsi);
  Log(_T(" RDI    %.16I64IX\r\n"), pExceptionInfo->ContextRecord->Rdi);
  Log(_T(" R8     %.16I64IX\r\n"), pExceptionInfo->ContextRecord->R8);
  Log(_T(" R9     %.16I64IX\r\n"), pExceptionInfo->ContextRecord->R9);
  Log(_T(" R10    %.16I64IX\r\n"), pExceptionInfo->ContextRecord->R10);
  Log(_T(" R11    %.16I64IX\r\n"), pExceptionInfo->ContextRecord->R11);
  Log(_T(" R12    %.16I64IX\r\n"), pExceptionInfo->ContextRecord->R12);
  Log(_T(" R13    %.16I64IX\r\n"), pExceptionInfo->ContextRecord->R13);
  Log(_T(" R14    %.16I64IX\r\n"), pExceptionInfo->ContextRecord->R14);
  Log(_T(" R15    %.16I64IX\r\n"), pExceptionInfo->ContextRecord->R15);
  Log(_T(" CS:RIP %04X:%.16I64IX\r\n"), static_cast<DWORD>(pExceptionInfo->ContextRecord->SegCs), pExceptionInfo->ContextRecord->Rip);
  Log(_T(" SS:RSP %04X:%.16I64IX\r\n"), static_cast<DWORD>(pExceptionInfo->ContextRecord->SegSs), pExceptionInfo->ContextRecord->Rsp);
  Log(_T(" RBP    %.16I64IX\r\n"), pExceptionInfo->ContextRecord->Rbp);
  Log(_T(" DS     %04X\r\n"), static_cast<DWORD>(pExceptionInfo->ContextRecord->SegDs));
  Log(_T(" ES     %04X\r\n"), static_cast<DWORD>(pExceptionInfo->ContextRecord->SegEs));
  Log(_T(" FS     %04X\r\n"), static_cast<DWORD>(pExceptionInfo->ContextRecord->SegFs));
  Log(_T(" GS     %04X\r\n"), static_cast<DWORD>(pExceptionInfo->ContextRecord->SegGs));
  Log(_T(" Flags  %08X\r\n"), pExceptionInfo->ContextRecord->EFlags);
#else
  Log(_T("Registers:\r\n EAX    %08X\r\n"), pExceptionInfo->ContextRecord->Eax);
  Log(_T(" EBX    %08X\r\n"), pExceptionInfo->ContextRecord->Ebx);
  Log(_T(" ECX    %08X\r\n"), pExceptionInfo->ContextRecord->Ecx);
  Log(_T(" EDX    %08X\r\n"), pExceptionInfo->ContextRecord->Edx);
  Log(_T(" ESI    %08X\r\n"), pExceptionInfo->ContextRecord->Esi);
  Log(_T(" EDI    %08X\r\n"), pExceptionInfo->ContextRecord->Edi);
  Log(_T(" CS:EIP %04X:%08X\r\n"), static_cast<DWORD>(pExceptionInfo->ContextRecord->SegCs), pExceptionInfo->ContextRecord->Eip);
  Log(_T(" SS:ESP %04X:%08X\r\n"), static_cast<DWORD>(pExceptionInfo->ContextRecord->SegSs), pExceptionInfo->ContextRecord->Esp);
  Log(_T(" EBP    %08X\r\n"), pExceptionInfo->ContextRecord->Ebp);
  Log(_T(" DS     %04X\r\n"), static_cast<DWORD>(pExceptionInfo->ContextRecord->SegDs));
  Log(_T(" ES     %04X\r\n"), static_cast<DWORD>(pExceptionInfo->ContextRecord->SegEs));
  Log(_T(" FS     %04X\r\n"), static_cast<DWORD>(pExceptionInfo->ContextRecord->SegFs));
  Log(_T(" GS     %04X\r\n"), static_cast<DWORD>(pExceptionInfo->ContextRecord->SegGs));
  Log(_T(" Flags  %08X\r\n"), pExceptionInfo->ContextRecord->EFlags);
#endif  
  Log(_T("\r\n"));
}

void CExceptionLogger::LogThreadDetails(HANDLE hToolHelp32Snap, DWORD dwProcessID)
{
  Log(_T("Threads:\r\n"));

  //Fill in the size of the structure before using it. 
  THREADENTRY32 te32;; 
  te32.dwSize = sizeof(THREADENTRY32); 

  //Walk the thread snapshot to find all threads of the process. 
  //If the thread belongs to the process, add its information 
  //to the display list.
  if (m_lpfnThread32First(hToolHelp32Snap, &te32)) 
  { 
    do 
    { 
      if (te32.th32OwnerProcessID == dwProcessID) 
      {
        Log(_T(" Thread ID: 0x%08X\r\n"), te32.th32ThreadID);
        Log(_T(" Priority Level: %d\r\n"), te32.tpBasePri);
        Log(_T(" Delta Priority: %d\r\n"), te32.tpDeltaPri);
        Log(_T(" References: %d\r\n"), te32.cntUsage);

        //Write out some detailed info on each thread (over and above what ToolHelp32 gives you)
        HANDLE hThread = m_lpfnOpenThread ? m_lpfnOpenThread(THREAD_QUERY_INFORMATION, FALSE, te32.th32ThreadID) : NULL;
        if (hThread)
        {
          FILETIME ct;
          FILETIME et;
          FILETIME kt;
          FILETIME ut;
          if (GetThreadTimes(hThread, &ct, &et, &kt, &ut))
          {
            SYSTEMTIME st;
            FileTimeToSystemTime(&ct, &st);
            Log(_T(" Creation Time: %02d:%02d:%02d.%03d %d/%d/%d (D/M/Y)\r\n"), st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, st.wDay, st.wMonth, st.wYear);
            unsigned __int64 TimeTaken;
            TimeTaken = ((unsigned __int64)(kt.dwHighDateTime) << 32);
            TimeTaken += kt.dwLowDateTime;
            Log(_T("  Kernel Time (Seconds): %I64u\r\n"), TimeTaken/10000000);
            TimeTaken = ((unsigned __int64)(ut.dwHighDateTime) << 32);
            TimeTaken += ut.dwLowDateTime;
            Log(_T(" User Time: (Seconds) %I64u\r\n"), TimeTaken/10000000);
          }
          CloseHandle(hThread);
        }
        Log(_T("\r\n"));
      }
    } 
    while (m_lpfnThread32Next(hToolHelp32Snap, &te32)); 
  } 
  else
    Log(_T(" Failed in call to Thread32First, Error:%d\r\n\r\n"), GetLastError());
}

//Coverts a linear address to a module, section, offset, name of section
BOOL CExceptionLogger::GetAddressDetails(void* pAddress, LPTSTR pszModule, DWORD& dwOffset, char* pszSectionName)
{
  //First thing to do is we need to get the base address in memory (i.e. a HINSTANCE) from pAddress
  MEMORY_BASIC_INFORMATION MemInfo;
  if (!VirtualQuery(pAddress, &MemInfo, sizeof(MEMORY_BASIC_INFORMATION)))
    return FALSE;

  //Check that MemInfo.AllocationBase is valid
  if (MemInfo.State == MEM_FREE)
    return FALSE;

  //From the HINSTANCE we can get the module name
  HMODULE hModule = (HMODULE) MemInfo.AllocationBase;
  if (!GetModuleFileName(hModule, pszModule, _MAX_PATH))
    return FALSE;

  //Now do our in memory traversal of the PE image to loop across the sections in that image
  PIMAGE_DOS_HEADER pDosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
  PIMAGE_NT_HEADERS pNTHeader = reinterpret_cast<PIMAGE_NT_HEADERS>((reinterpret_cast<BYTE*>(pDosHeader)) + pDosHeader->e_lfanew);
  PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pNTHeader);

  //Express the "pAddress" parameter as an "RVA"
  DWORD dwRVAAddress = static_cast<DWORD>(static_cast<BYTE*>(pAddress) - static_cast<BYTE*>(MemInfo.AllocationBase)); 

  //Loop across the sections to find the one which contains our faulting address
  for (WORD i=0; i<pNTHeader->FileHeader.NumberOfSections; i++, pSection++)
  {
    DWORD dwSectionStart = pSection->VirtualAddress;
    DWORD dwSectionEnd = dwSectionStart + max(pSection->SizeOfRawData, pSection->Misc.VirtualSize);

    //Is the "pAddress" parameter (expressed as a RVA) inside this section?
    if ((dwRVAAddress >= dwSectionStart) && (dwRVAAddress <= dwSectionEnd))
    {
      dwOffset = dwRVAAddress - dwSectionStart;
      CopyMemory(pszSectionName, pSection->Name, IMAGE_SIZEOF_SHORT_NAME);
      pszSectionName[IMAGE_SIZEOF_SHORT_NAME] = 0; //Don't forget to NULL terminate the Section name
      return TRUE;
    }
  }

  //Got here, then return failure
  return FALSE;
}

void CExceptionLogger::LogStack(CONTEXT* pContext, HANDLE hProcess)
{
  Log(_T("Call Stack:\r\n"));

  //Variables required inside the loop
  HANDLE hThread = GetCurrentThread();

  //Initialize the STACKFRAME variable to start walking the stack from
  STACKFRAME64 sf;
  ZeroMemory(&sf, sizeof(sf));
#ifdef _WIN64
  sf.AddrPC.Offset    = pContext->Rip;
  sf.AddrPC.Mode      = AddrModeFlat;
  sf.AddrStack.Offset = pContext->Rsp;
  sf.AddrStack.Mode   = AddrModeFlat;
  sf.AddrFrame.Offset = pContext->Rbp;
  sf.AddrFrame.Mode   = AddrModeFlat;
#else
  sf.AddrPC.Offset    = pContext->Eip;
  sf.AddrPC.Mode      = AddrModeFlat;
  sf.AddrStack.Offset = pContext->Esp;
  sf.AddrStack.Mode   = AddrModeFlat;
  sf.AddrFrame.Offset = pContext->Ebp;
  sf.AddrFrame.Mode   = AddrModeFlat;
#endif

  //We need the page size of memory for calls to LogRawMemory
  SYSTEM_INFO si;
  GetSystemInfo(&si);

  //Now let's walk the walk
  BOOL bContinue = TRUE;
  while (bContinue)
  {
    #ifdef _WIN64
    if (m_lpfnStackWalk64(IMAGE_FILE_MACHINE_AMD64, hProcess, hThread, &sf, pContext, NULL, m_lpfnSymFunctionTableAccess64, m_lpfnSymGetModuleBase64, NULL))
    #else
    if (m_lpfnStackWalk64(IMAGE_FILE_MACHINE_I386, hProcess, hThread, &sf, pContext, NULL, m_lpfnSymFunctionTableAccess64, m_lpfnSymGetModuleBase64, NULL))
    #endif
    {
      DWORD dwOffset;
      char pszSectionName[IMAGE_SIZEOF_SHORT_NAME+1];
      if (GetAddressDetails(reinterpret_cast<PVOID>(sf.AddrPC.Offset), m_szTempFileName, dwOffset, pszSectionName))
      {
      #ifdef _WIN64
        Log(_T(" 0x%.16I64IX [%hs]:0x%08X %s"), sf.AddrPC.Offset, pszSectionName, dwOffset, m_szTempFileName);
      #else
        Log(_T(" 0x%08X [%hs]:0x%08X %s"), static_cast<DWORD>(sf.AddrPC.Offset), pszSectionName, dwOffset, m_szTempFileName);
      #endif
      }
      else
      {
        //Fall back to just reporting the linear faulting address, rather than the additional details
      #ifdef _WIN64
        Log(_T(" 0x%.16I64IX [UNKNOWN]"), sf.AddrPC.Offset);
      #else
        Log(_T(" 0x%08X [UNKNOWN]"), sf.AddrPC.Offset);
      #endif
      }

      //Get the Symbol Info for the offending address
      SYMBOL_INFO* pSymbolInfo = reinterpret_cast<SYMBOL_INFO*>(m_bySymbolInfo);
      pSymbolInfo->SizeOfStruct = sizeof(m_bySymbolInfo);
      pSymbolInfo->MaxNameLen = 1024;
      DWORD64 SymbolOffset;
      if (m_lpfnSymFromAddr(hProcess, sf.AddrPC.Offset, &SymbolOffset, pSymbolInfo))
      {
      #ifdef _WIN64
        Log(_T(" %hs+0x%.16I64IX"), pSymbolInfo->Name, SymbolOffset);
      #else
        Log(_T(" %hs+0x%08X"), pSymbolInfo->Name, static_cast<DWORD>(SymbolOffset));
      #endif
      }

      //Get the source line if we can
      IMAGEHLP_LINE64 LineInfo;
      LineInfo.SizeOfStruct = sizeof(IMAGEHLP_LINE);
      DWORD dwLineDisplacement;
      if (m_lpfnSymGetLineFromAddr64(hProcess, sf.AddrPC.Offset, &dwLineDisplacement, &LineInfo))
        Log(_T(" %hs line %u"), LineInfo.FileName, LineInfo.LineNumber);

      //Write out the variables at this stack frame
      if (m_dwFlags & EXCEPTION_LOGGER_CALLSTACK_SYMBOLS)
      {
        Log(_T("\r\n  Variables\r\n"));
        IMAGEHLP_STACK_FRAME imageHelpStackFrame;
        imageHelpStackFrame.InstructionOffset = sf.AddrPC.Offset;
        m_lpfnSymSetContext(hProcess, &imageHelpStackFrame, 0);
        m_lpfnSymEnumSymbols(hProcess, 0, 0, EnumSymbols, &sf);
      }
    #ifdef _WIN64
      Log(_T("\r\n  Frame Pointer: 0x%.16I64IX\r\n"), sf.AddrFrame.Offset);
    #else
      Log(_T("\r\n  Frame Pointer: 0x%08X\r\n"), static_cast<DWORD>(sf.AddrFrame.Offset));
    #endif

      //Write out the raw call stack also
      if (m_dwFlags & EXCEPTION_LOGGER_RAW_CALLSTACK_STACK)
      {
        Log(_T("\r\n  Raw Stack Dump\r\n"));
        LogRawMemory((reinterpret_cast<LPBYTE>(sf.AddrFrame.Offset))-160, si.dwPageSize);
      }

      //Write out the code around the faulting address 
      if (m_dwFlags & EXCEPTION_LOGGER_RAW_CALLSTACK_CODE)
      {
        Log(_T("\r\n  Machine code\r\n"));
        LogRawMemory((reinterpret_cast<LPBYTE>(sf.AddrPC.Offset))-160, si.dwPageSize);
      }

      //Start the next stack frame log on a new line
      Log(_T("\r\n"));
    }
    else
      bContinue = FALSE;
  }
  Log(_T("\r\n"));
}

void CExceptionLogger::LogRawMemory(LPBYTE lpStart, DWORD dwPageSize)
{
  //Work out the base address of the memory region associated with "lpStart"
  MEMORY_BASIC_INFORMATION mbi;
  if (!VirtualQuery(lpStart, &mbi, sizeof(mbi)))
  {
  #ifdef _WIN64
    Log(_T("   Unable to get base address of the memory at 0x%.16I64IX\r\n"), lpStart);
  #else
    Log(_T("   Unable to get base address of the memory at 0x%08X\r\n"), lpStart);
  #endif
    return;
  }

  //Work out the start address of the page and its size
  LPBYTE lpLoggedAddress = reinterpret_cast<LPBYTE>(mbi.BaseAddress);
  SIZE_T dwProtectedSize = min(mbi.RegionSize, dwPageSize);

  //tweak the page protection if we need to
  DWORD dwOldProtection;
  if (!VirtualProtect(mbi.BaseAddress, dwProtectedSize, PAGE_READWRITE, &dwOldProtection))
  {
  #ifdef _WIN64
    Log(_T("   Unable to get read access to memory, Address: 0x%.16I64IX, Base Address: 0x%.16I64IX, Size: %I64d, Error:%d\r\n"), lpStart, mbi.BaseAddress, dwProtectedSize, GetLastError());
  #else
    Log(_T("   Unable to get read access to memory, Address: 0x%08X, Base Address: 0x%08X, Size: %d, Error:%d\r\n"), lpStart, mbi.BaseAddress, dwProtectedSize, GetLastError());
  #endif
    return;
  }

  //Dump out the data 64 bytes per line
  SIZE_T nLines = dwProtectedSize / 64;
  for (SIZE_T i=0; i<nLines; i++)
  {
  #ifdef _WIN64
    DWORD64 dwLoggedAddress = reinterpret_cast<DWORD64>(lpLoggedAddress);
    Log(_T("   0x%.16I64IX"), dwLoggedAddress);
  #else
    Log(_T("   0x%08X"), lpLoggedAddress);
  #endif
    for (int j=0; j<64; j++)
    {
      Log(_T(" %02X"), lpLoggedAddress[j]);
      if (((j % 8) == 7)  && (j != 63))
        Log(_T(" -"));
    }
    Log(_T("\r\n"));

    //Move to the next line
    lpLoggedAddress += 64;
  }

  //restore the protection status of the memory
  DWORD dwRestoredProtection;
  VirtualProtect(mbi.BaseAddress, dwProtectedSize, dwOldProtection, &dwRestoredProtection);
}

BOOL CExceptionLogger::EnumSymbols(PSYMBOL_INFO pSymbolInfo, ULONG /*SymbolSize*/, PVOID pUserContext)
{
  LogSymbol(pSymbolInfo, reinterpret_cast<STACKFRAME64*>(pUserContext));
  Log(_T("\r\n")); //Each symbol gets its own line

  //Continue enumeration
  return TRUE;
}

void CExceptionLogger::LogSymbol(PSYMBOL_INFO pSymbolInfo, STACKFRAME64* pStackFrame)
{
  //Display details on the symbols type
  if (pSymbolInfo->Flags & IMAGEHLP_SYMBOL_INFO_PARAMETER)
    Log(_T("   Parameter: "));
  else if (pSymbolInfo->Flags & IMAGEHLP_SYMBOL_FUNCTION)
    Log(_T("   Function:  "));
  else if (pSymbolInfo->Flags & IMAGEHLP_SYMBOL_INFO_LOCAL)
    Log(_T("   Local:     "));
  else if (pSymbolInfo->Flags & IMAGEHLP_SYMBOL_INFO_CONSTANT)
    Log(_T("   Constant:  "));
  else
    Log(_T(" "));

  //Display the symbols name
  Log(_T(" %hs"), pSymbolInfo->Name);

  //Return immediately if the symbol is not for data
  if (pSymbolInfo->Tag != 7) //SymTagData is 7 as taken from the DIA SDK Header file cvconst.h
    return;

  //Display the value if valid
  if (pSymbolInfo->Flags & IMAGEHLP_SYMBOL_INFO_VALUEPRESENT)
    Log(_T(", Value: %I64u"), pSymbolInfo->Value);

  //Punt on register values
  if (pSymbolInfo->Flags & IMAGEHLP_SYMBOL_INFO_REGISTER)
  {
    Log(_T(", Register"));
    return;
  } 

  //Work out the address of the variable
  DWORD64 dwSymbolAddress = 0;
  if (pSymbolInfo->Flags & IMAGEHLP_SYMBOL_INFO_REGRELATIVE)
  {
    Log(_T(", Register Relative"));
    dwSymbolAddress = pStackFrame->AddrFrame.Offset;
    dwSymbolAddress += pSymbolInfo->Address;
  }
  else 
  {
    if (pSymbolInfo->Flags & IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE)
    {
      Log(_T(", Frame Relative"));
      return;
    }

    dwSymbolAddress = (static_cast<DWORD>(pSymbolInfo->Address));
  }
  Log(_T(", Address: %I64X"), dwSymbolAddress);

  BOOL bHandled = LogUDTSymbolDetails(pSymbolInfo->TypeIndex, pSymbolInfo->ModBase, dwSymbolAddress, 3);
  if (!bHandled)
  {
    //Get the type of the symbol
    DWORD dwType = GetBasicType(pSymbolInfo->TypeIndex, pSymbolInfo->ModBase);

    //Now that we have the type display the actual symbols value
    Log(_T(", "));
    LogBasicSymbolDetails(dwType, pSymbolInfo->Size, reinterpret_cast<void*>(dwSymbolAddress));
  }
}

BOOL CExceptionLogger::LogUDTSymbolDetails(DWORD dwTypeIndex, ULONG64 modBase, ULONG64 dwOffset, DWORD dwIndent)
{
	if( dwIndent > 5 )
		return TRUE;
  __try
  {
    HANDLE hProcess = GetCurrentProcess();

    //First get the symbol name, which will either be the 
    //type name if a UDT or the member name otherwise
    wchar_t* pszTypeName = NULL;
    if (m_lpfnSymGetTypeInfo(hProcess, modBase, dwTypeIndex, TI_GET_SYMNAME, &pszTypeName))
    {
      Log(_T(" %ls"), pszTypeName);
      LocalFree(pszTypeName);
    }

    //Next we need to find out how many children this symbol has
    DWORD dwChildren = 0;
    m_lpfnSymGetTypeInfo(hProcess, modBase, dwTypeIndex, TI_GET_CHILDRENCOUNT, &dwChildren);

    //No children then return immediately
    if (dwChildren == 0)
      return FALSE;
    //Form the identation correctly
	Log(_T("\tChildren:\r\n"));
    DWORD j;
    for (j=0; j<dwIndent; j++)
      Log(_T("\t"));

    //Next get all the type Id's for all the children
    struct myTI_FIND_PARAMS : TI_FINDCHILDREN_PARAMS
    {
      ULONG nOtherChildren[1024];
    } myFindParams;
    myFindParams.Count = dwChildren;
    myFindParams.Start = 0;
    if (!m_lpfnSymGetTypeInfo(hProcess, modBase, dwTypeIndex, TI_FINDCHILDREN, &myFindParams))
      return FALSE;

    //Iterate thro all the children
    for (DWORD i=0; i<dwChildren; i++)
    {
      if (!LogUDTSymbolDetails(myFindParams.ChildId[i], modBase, dwOffset, dwIndent+1))
      {
        //This child item must be a basic type, so log it's info
      
        //First need to get it's offset relative to the parent
        DWORD dwMemberOffset = 0;
        m_lpfnSymGetTypeInfo(hProcess, modBase, myFindParams.ChildId[i], TI_GET_OFFSET, &dwMemberOffset);

        //Get the TypeID of this child
        DWORD dwTypeId = 0;
        m_lpfnSymGetTypeInfo(hProcess, modBase, myFindParams.ChildId[i], TI_GET_TYPEID, &dwTypeId);

        //Get the length of the child
        ULONG64 Length = 0;
        m_lpfnSymGetTypeInfo(hProcess, modBase, dwTypeId, TI_GET_LENGTH, &Length);

        //get the basic type of the child
        DWORD dwBasicType = GetBasicType(myFindParams.ChildId[i], modBase);

        //Now call the helper function to display all the child's details
        ULONG64 dwSymbolAddress = dwOffset + dwMemberOffset;     
        Log(_T(", "));
        LogBasicSymbolDetails(dwBasicType, Length, reinterpret_cast<void*>(dwSymbolAddress));

        //Each child starts on a new line
		if( i >= 10 )
		{
			Log(_T("\r\n"));
			for (j=0; j<dwIndent; j++)
				Log(_T("\t"));
			break;
		}
        if (i<(dwChildren-1))
        {
          Log(_T("\r\n"));
          for (j=0; j<dwIndent; j++)
            Log(_T("\t"));
        }
      }
    }
  }
  __except(1)
  {
  }

  return TRUE;
}

void CExceptionLogger::LogBasicSymbolDetails(DWORD dwBasicType, DWORD64 dwLength, void* pSymbolAddress)
{
  __try
  {
    switch (dwBasicType)
    {
      case 0: //btNoType is 0 from DIA SDK header file cvconst.h
      {
        //Log(_T("No Type"));
		Log(_T("No Type, Value: %08X"), *((DWORD*)pSymbolAddress));
        break;
      }
      case 1: //btVoid is 1 from DIA SDK header file cvconst.h
      {
        Log(_T("void, Value: %08X"), *(static_cast<DWORD*>(pSymbolAddress)));
        break;
      }
      case 2: //btChar is 2 from DIA SDK header file cvconst.h
      {
        BYTE* pAddr = static_cast<BYTE*>(pSymbolAddress);
        Log(_T("char, len: %d, value(s): "), dwLength);
        for (DWORD64 i=0; i<dwLength; i++)
          Log(_T("%hc"), pAddr[i]);
        break;
      }
      case 6: //btInt is 6 from DIA SDK header file cvconst.h
      {
        //Handle the special case of a short
        if (dwLength == 2 || dwLength == 6)
        {
          short* pAddr = static_cast<short*>(pSymbolAddress);
          DWORD64 dwSize = dwLength / sizeof(short);
          Log(_T("short, len: %d, value(s): "), dwSize);
          for (DWORD64 i=0; i<dwSize; i++)
            Log(_T("%d "), pAddr[i]);
        }
        else
        {
          int* pAddr = static_cast<int*>(pSymbolAddress);
          DWORD64 dwSize = dwLength / sizeof(int);
          Log(_T("int, len: %d, value(s): "), dwSize);
          for (DWORD64 i=0; i<dwSize; i++)
            Log(_T("%d "), pAddr[i]);
        }
        break;
      }
      case 7: //btUInt is 7 from DIA SDK header file cvconst.h
      {
        //Handle the special case of a WORD
        if (dwLength == 2 || dwLength == 6)
        {
          WORD* pAddr = static_cast<WORD*>(pSymbolAddress);
          DWORD64 dwSize = dwLength / sizeof(WORD);
          Log(_T("WORD, len: %d, value(s): "), dwSize);
          for (DWORD64 i=0; i<dwSize; i++)
            Log(_T("%u "), pAddr[i]);
        }
        else
        {
          unsigned int* pAddr = static_cast<unsigned int*>(pSymbolAddress);
          DWORD64 dwSize = dwLength / sizeof(unsigned int);
          Log(_T("unsigned int, len: %d, value(s): "), dwSize);
          for (DWORD64 i=0; i<dwSize; i++)
            Log(_T("%u "), pAddr[i]);
        }
        break;
      }
      case 8: //btFloat is 8 from DIA SDK header file cvconst.h
      {
        if (dwLength == 4)
          Log(_T("float, Value: %f"), *(static_cast<float*>(pSymbolAddress)));
        else if (dwLength == 8)
          Log(_T("double, Value: %lf"), *(static_cast<double*>(pSymbolAddress)));
        else 
        {
          BYTE* pAddr = static_cast<BYTE*>(pSymbolAddress);
          Log(_T("btFloat, len (bytes): %d, value(s): "), dwLength);
          for (DWORD64 i=0; i<dwLength; i++)
            Log(_T("%02X "), pAddr[i]);
        }
        break;
      }
      case 13: //btLong is 13 from DIA SDK header file cvconst.h
      {
        long* pAddr = static_cast<long*>(pSymbolAddress);
        DWORD64 dwSize = dwLength / sizeof(long);
        Log(_T("long, len: %d, value(s): "), dwSize);
        for (DWORD64 i=0; i<dwSize; i++)
          Log(_T("%ld "), pAddr[i]);
        break;
      }
      case 14: //btULong is 14 from DIA SDK header file cvconst.h
      {
        unsigned long* pAddr = static_cast<unsigned long*>(pSymbolAddress);
        DWORD64 dwSize = dwLength / sizeof(unsigned long);
        Log(_T("unsigned long, len: %d, value(s): "), dwSize);
        for (DWORD64 i=0; i<dwSize; i++)
          Log(_T("%lu "), pAddr[i]);
        break;
      }
      default:
      {
        Log(_T("Unknown Type"));
        break;
      }
    }
  }
  __except(1)
  {
    Log(_T("Error displaying symbol"));
  }
}

DWORD CExceptionLogger::GetBasicType(DWORD dwTypeIndex, DWORD64 modBase)
{
  HANDLE hProcess = GetCurrentProcess();

  DWORD dwType;
  if (m_lpfnSymGetTypeInfo(hProcess, modBase, dwTypeIndex, TI_GET_BASETYPE, &dwType))
    return dwType;

  DWORD dwTypeID;
  if (m_lpfnSymGetTypeInfo(hProcess, modBase, dwTypeIndex, TI_GET_TYPEID, &dwTypeID))
  {
    if (m_lpfnSymGetTypeInfo(hProcess, modBase, dwTypeID, TI_GET_BASETYPE, &dwType) )
      return dwType;
  }

  return 0;
}
